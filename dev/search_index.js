var documenterSearchIndex = {"docs":
[{"location":"linear_affine/#Linear-and-Affine-Subspaces-1","page":"Linear and Affine Subspaces","title":"Linear and Affine Subspaces","text":"","category":"section"},{"location":"linear_affine/#","page":"Linear and Affine Subspaces","title":"Linear and Affine Subspaces","text":"We provide built-in data structures to work with affine and linear subspaces L. L can be represented in either extrinsic coordinates x with L = x  Ax = b  or in intrinsic coordinates u with L=Bu+p  u.","category":"page"},{"location":"linear_affine/#Coordinates-1","page":"Linear and Affine Subspaces","title":"Coordinates","text":"","category":"section"},{"location":"linear_affine/#","page":"Linear and Affine Subspaces","title":"Linear and Affine Subspaces","text":"To specify which coordinates are given / expected the following can be used:","category":"page"},{"location":"linear_affine/#","page":"Linear and Affine Subspaces","title":"Linear and Affine Subspaces","text":"Coordinates\nIntrinsic\nExtrinsic","category":"page"},{"location":"linear_affine/#HomotopyContinuation2.Coordinates","page":"Linear and Affine Subspaces","title":"HomotopyContinuation2.Coordinates","text":"Coordinates\n\nA type used for encoding the used coordinates and for performing coordinate changes.\n\nCurrently supported coordinates are:\n\nIntrinsic\nExtrinsic\n\n\n\n\n\n","category":"type"},{"location":"linear_affine/#HomotopyContinuation2.Intrinsic","page":"Linear and Affine Subspaces","title":"HomotopyContinuation2.Intrinsic","text":"Intrinsic <: Coordinates\n\nIndicates the use of the intrinsic description of an affine subspace. See also AffineIntrinsic.\n\n\n\n\n\n","category":"constant"},{"location":"linear_affine/#HomotopyContinuation2.Extrinsic","page":"Linear and Affine Subspaces","title":"HomotopyContinuation2.Extrinsic","text":"Extrinsic <: Coordinates\n\nIndicates the use of the extrinsic description of an affine subspace. See also AffineExtrinsic.\n\n\n\n\n\n","category":"constant"},{"location":"linear_affine/#Affine-Subspace-1","page":"Linear and Affine Subspaces","title":"Affine Subspace","text":"","category":"section"},{"location":"linear_affine/#","page":"Linear and Affine Subspaces","title":"Linear and Affine Subspaces","text":"AffineSubspace\nAffineExtrinsic\nAffineIntrinsic","category":"page"},{"location":"linear_affine/#HomotopyContinuation2.AffineSubspace","page":"Linear and Affine Subspaces","title":"HomotopyContinuation2.AffineSubspace","text":"AffineSubspace(A, b)\n\nAn m-dimensional affine subspace L in n-dimensional space given by the extrinsic description L =  x  A x = b .\n\njulia> A = AffineSubspace([1 0 3; 2 1 3], [5, -2])\n1-dim. affine subspace {x|Ax=b} with eltype Float64:\nA:\n2×3 Array{Float64,2}:\n 1.0  0.0  3.0\n 2.0  1.0  3.0\nb:\n2-element Array{Float64,1}:\n  5.0\n -2.0\n\njulia> dim(A)\n1\n\njulia> codim(A)\n2\n\njulia> ambient_dim(A)\n3\n\nAn AffineSubspace holds always its extrinsic description, see also AffineIntrinsic, as well as its intrinsic description, see AffineExtrinsic.\n\njulia> intrinsic(A)\nAffineIntrinsic{Float64}:\nA:\n3×1 Array{Float64,2}:\n -0.6882472016116853\n  0.6882472016116853\n  0.22941573387056186\nb₀:\n3-element Array{Float64,1}:\n -3.0526315789473677\n -3.947368421052632\n  2.684210526315789\n\nAn AffineSubspace can be evaluated with either using Intrinsic or Extrinsic coordinates.\n\njulia> u = [0.5]\n1-element Array{Float64,1}:\n 0.5\n\njulia> x = A(u, Intrinsic)\n3-element Array{Float64,1}:\n -3.3967551797532103\n -3.6032448202467893\n  2.79891839325107\n\njulia> A(x, Extrinsic)\n  2-element Array{Float64,1}:\n   0.0\n   0.0\n\nTo change the used coordinates you can use coord_change.\n\njulia> coord_change(A, Extrinsic, Intrinsic, x)\n1-element Array{Float64,1}:\n 0.49999999999999994\n\n\n\n\n\n","category":"type"},{"location":"linear_affine/#HomotopyContinuation2.AffineExtrinsic","page":"Linear and Affine Subspaces","title":"HomotopyContinuation2.AffineExtrinsic","text":"AffineExtrinsic\n\nExtrinsic description of an m-dimensional affine subspace L in n-dimensional space. That is L =  x  A x = b .\n\n\n\n\n\n","category":"type"},{"location":"linear_affine/#HomotopyContinuation2.AffineIntrinsic","page":"Linear and Affine Subspaces","title":"HomotopyContinuation2.AffineIntrinsic","text":"AffineIntrinsic\n\nIntrinsic description of an m-dimensional affine subspace L in n-dimensional space. That is L =  u  A u + b₀ . Here, A and b₀ are in orthogonal coordinates. That is, the columns of A are orthonormal and A b₀ = 0.\n\n\n\n\n\n","category":"type"},{"location":"linear_affine/#Functions-1","page":"Linear and Affine Subspaces","title":"Functions","text":"","category":"section"},{"location":"linear_affine/#","page":"Linear and Affine Subspaces","title":"Linear and Affine Subspaces","text":"ambient_dim\ncodim\ncoord_change\ndim\nintrinsic\nextrinsic\ngeodesic\ngeodesic_distance\nrand_affine_subspace","category":"page"},{"location":"linear_affine/#HomotopyContinuation2.ambient_dim","page":"Linear and Affine Subspaces","title":"HomotopyContinuation2.ambient_dim","text":"ambient_dim(A::AffineSubspace)\n\nDimension of ambient space of the affine subspace A.\n\n\n\n\n\n","category":"function"},{"location":"linear_affine/#HomotopyContinuation2.codim","page":"Linear and Affine Subspaces","title":"HomotopyContinuation2.codim","text":"codim(A::AffineExtrinsic)\n\nCodimension of the affine subspace A.\n\n\n\n\n\ncodim(A::AffineIntrinsic)\n\nCodimension of the affine subspace A.\n\n\n\n\n\ncodim(A::AffineSubspace)\n\nCodimension of the affine subspace A.\n\n\n\n\n\n","category":"function"},{"location":"linear_affine/#HomotopyContinuation2.coord_change","page":"Linear and Affine Subspaces","title":"HomotopyContinuation2.coord_change","text":"coord_change(A::AffineSubspace, C₁::Coordinates, C₂::Coordinates, p)\n\nGiven an affine subspace A and a point p in coordinates C₁ compute the point x describing p in coordinates C₂.\n\nExample\n\njulia> A = AffineSubspace([1 0 3; 2 1 3], [5, -2]);\n\njulia> u = [1.25];\n\njulia> x = coord_change(A, Intrinsic, Extrinsic, u)\n3-element Array{Float64,1}:\n -3.9129405809619744\n -3.087059419038025\n  2.9709801936539915\n\njulia> A(x, Extrinsic)\n2-element Array{Float64,1}:\n 0.0\n 0.0\n\njulia> x - A(u, Intrinsic)\n3-element Array{Float64,1}:\n 0.0\n 0.0\n 0.0\n\n\n\n\n\n","category":"function"},{"location":"linear_affine/#HomotopyContinuation2.dim","page":"Linear and Affine Subspaces","title":"HomotopyContinuation2.dim","text":"dim(A::AffineExtrinsic)\n\nDimension of the affine subspace A.\n\n\n\n\n\ndim(A::AffineIntrinsic)\n\nDimension of the affine subspace A.\n\n\n\n\n\ndim(A::AffineSubspace)\n\nDimension of the affine subspace A.\n\n\n\n\n\n","category":"function"},{"location":"linear_affine/#HomotopyContinuation2.intrinsic","page":"Linear and Affine Subspaces","title":"HomotopyContinuation2.intrinsic","text":"intrinsic(A::AffineSubspace)\n\nObtain the intrinsic description of A, see also AffineIntrinsic.\n\n\n\n\n\n","category":"function"},{"location":"linear_affine/#HomotopyContinuation2.extrinsic","page":"Linear and Affine Subspaces","title":"HomotopyContinuation2.extrinsic","text":"extrinsic(A::AffineSubspace)\n\nObtain the extrinsic description of A, see also AffineExtrinsic.\n\n\n\n\n\n","category":"function"},{"location":"linear_affine/#HomotopyContinuation2.geodesic","page":"Linear and Affine Subspaces","title":"HomotopyContinuation2.geodesic","text":"geodesic(A::AffineSubspace, B::AffineSubspace)\n\nReturns the geodesic γ(t) connecting A and B in the Grassmanian Gr(k+1n+1) where k is the dimension of A and n is the ambient dimension. See also Corollary 4.3 in [LKK19].\n\n[LKK19]: Lim, Lek-Heng, Ken Sze-Wai Wong, and Ke Ye. \"Numerical algorithms on the affine Grassmannian.\" SIAM Journal on Matrix Analysis and Applications 40.2 (2019): 371-393\n\n\n\n\n\n","category":"function"},{"location":"linear_affine/#HomotopyContinuation2.geodesic_distance","page":"Linear and Affine Subspaces","title":"HomotopyContinuation2.geodesic_distance","text":"geodesic_distance(A::AffineSubspace, B::AffineSubspace)\n\nCompute the geodesic distance between A and B in the affine Grassmanian Graff(k, n) where k = dim(A) and n is the amebient dimension. This follows the derivation in [LKK19].\n\n[LKK19]: Lim, Lek-Heng, Ken Sze-Wai Wong, and Ke Ye. \"Numerical algorithms on the affine Grassmannian.\" SIAM Journal on Matrix Analysis and Applications 40.2 (2019): 371-393.\n\n\n\n\n\n","category":"function"},{"location":"linear_affine/#HomotopyContinuation2.rand_affine_subspace","page":"Linear and Affine Subspaces","title":"HomotopyContinuation2.rand_affine_subspace","text":"rand_affine_subspace(n::Integer; dim | codim, real = false)\n\nGenerate a random AffineSubspace with given dimension dim or codimension codim (one of them has to be provided) in ambient space of dimension n. If real is true, then the extrinsic description is real. The subspace is generated by drawing each entry of the extrinsic description indepdently from a normal distribuation using randn.\n\nExample\n\njulia> rand_affine_subspace(3; dim = 1)\n1-dim. affine subspace {x|Ax=b} with eltype Complex{Float64}:\nA:\n2×3 Array{Complex{Float64},2}:\n  -1.73825+1.27987im   -0.0871343+0.840408im  -0.551957+0.106397im\n -0.597132-0.343965im   -0.122543-0.172715im   -1.04949+0.370917im\nb:\n2-element Array{Complex{Float64},1}:\n  0.47083334430689394 + 0.8099804422599071im\n -0.12018696822943896 + 0.11723026326952792im\n\njulia> rand_affine_subspace(4; codim = 1)\n3-dim. affine subspace {x|Ax=b} with eltype Complex{Float64}:\nA:\n1×4 Array{Complex{Float64},2}:\n 0.345705+0.0893881im  -0.430867-0.663249im  0.979969-0.569378im  -0.29722-0.192493im\nb:\n1-element Array{Complex{Float64},1}:\n 0.7749708228192062 + 0.9762873764567546im\n\n\n\n\n\n","category":"function"},{"location":"model_kit/#ModelKit-1","page":"ModelKit","title":"ModelKit","text":"","category":"section"},{"location":"model_kit/#","page":"ModelKit","title":"ModelKit","text":"ModelKit is the symbolic input and modeling language of HomotopyContinuation.jl. It is designed such that you can easily create an efficient formulation of your problem.","category":"page"},{"location":"model_kit/#Expressions-and-Variables-1","page":"ModelKit","title":"Expressions and Variables","text":"","category":"section"},{"location":"model_kit/#","page":"ModelKit","title":"ModelKit","text":"Expression\nVariable\n@var\n@unique_var","category":"page"},{"location":"model_kit/#HomotopyContinuation2.ModelKit.Expression","page":"ModelKit","title":"HomotopyContinuation2.ModelKit.Expression","text":"Expression <: Number\n\nA symbolic expression.\n\njulia> expr = (Variable(:x) + 1)^2\n(1 + x)^2\n\njulia> Expression(2)\n2\n\njulia> Expression(Variable(:x))\nx\n\n\n\n\n\n","category":"type"},{"location":"model_kit/#HomotopyContinuation2.ModelKit.Variable","page":"ModelKit","title":"HomotopyContinuation2.ModelKit.Variable","text":"Variable(name::Union{String,Symbol}, indices...) <: Number\n\nA data structure representing a variable.\n\njulia> Variable(:a)\na\n\njulia> Variable(:x, 1)\nx₁\n\njulia> Variable(:x, 10, 5)\nx₁₀₋₅\n\nEquality and ordering\n\nVariables are identified by their name and indices. That is, two variables are equal if and only if they have the same name and indices.\n\njulia> Variable(:a) == Variable(:a)\ntrue\n\njulia> Variable(:a, 1) == Variable(:a, 2)\nfalse\n\nSimilarly, variables are first ordered lexicographically by their name and then by their indices.\n\njulia> Variable(:a, 1) < Variable(:a, 2)\ntrue\n\njulia> Variable(:a, 1) < Variable(:b, 1)\ntrue\n\njulia> a = [Variable(:a, i, j) for i in 1:2, j in 1:2]\n2×2 Array{Variable,2}:\n a₁₋₁  a₁₋₂\n a₂₋₁  a₂₋₂\n\njulia> sort(vec(a))\n4-element Array{Variable,1}:\n a₁₋₁\n a₂₋₁\n a₁₋₂\n a₂₋₂\n\n\n\n\n\n","category":"type"},{"location":"model_kit/#HomotopyContinuation2.ModelKit.@var","page":"ModelKit","title":"HomotopyContinuation2.ModelKit.@var","text":"@var variable1 variable2 ...\n\nDeclare variables with the given names and automatically create the variable bindings. The macro supports indexing notation to create Arrays of variables.\n\nExamples\n\njulia> @var a b x[1:2] y[1:2,1:3]\n(a, b, Variable[x₁, x₂], Variable[y₁₋₁ y₁₋₂ y₁₋₃; y₂₋₁ y₂₋₂ y₂₋₃])\n\njulia> a\na\n\njulia> b\nb\n\njulia> x\n2-element Array{Variable,1}:\n x₁\n x₂\n\njulia> y\n2×3 Array{Variable,2}:\n y₁₋₁  y₁₋₂  y₁₋₃\n y₂₋₁  y₂₋₂  y₂₋₃\n\n\n\n\n\n","category":"macro"},{"location":"model_kit/#HomotopyContinuation2.ModelKit.@unique_var","page":"ModelKit","title":"HomotopyContinuation2.ModelKit.@unique_var","text":"@unique_var variable1 variable2\n\nThis is similar to @var with the only difference that the macro automatically changes the names of the variables to ensure uniqueness. However, the binding is still to the declared name. This is useful to ensure that there are no name collisions.\n\nExamples\n\njulia> @unique_var a b\n(a#591, b#592)\n\njulia> a\na#591\n\njulia> b\nb#592\n\n\n\n\n\n","category":"macro"},{"location":"model_kit/#Functions-1","page":"ModelKit","title":"Functions","text":"","category":"section"},{"location":"model_kit/#","page":"ModelKit","title":"ModelKit","text":"coefficients\ndegree\ndegrees(::AbstractVector{Expression})\ndifferentiate\ndense_poly\nevaluate\nexpand\nexponents_coefficients\nhorner\nnvariables(::Expression)\nmonomials\nsubs\nrand_poly\nto_number\nvariables(::Expression)","category":"page"},{"location":"model_kit/#HomotopyContinuation2.ModelKit.coefficients","page":"ModelKit","title":"HomotopyContinuation2.ModelKit.coefficients","text":"coefficients(f::Expression, vars::AbstractVector{Variable})\n\nReturn all coefficients of the given polynomial f for the given variables vars. This assumes that the expression f is already expanded, e.g., with expand.\n\n\n\n\n\n","category":"function"},{"location":"model_kit/#HomotopyContinuation2.ModelKit.degree","page":"ModelKit","title":"HomotopyContinuation2.ModelKit.degree","text":"degree(f::Expression, vars = variables(f); expanded = false)\n\nCompute the degree of the expression f  in vars. Unless expanded is true the expression is first expanded.\n\n\n\n\n\n","category":"function"},{"location":"model_kit/#HomotopyContinuation2.ModelKit.degrees-Tuple{AbstractArray{Expression,1}}","page":"ModelKit","title":"HomotopyContinuation2.ModelKit.degrees","text":"degrees(f::AbstractVector{Expression}, vars = variables(f); expanded = false)\n\nCompute the degrees of the expressions f in vars. Unless expanded is true the expressions are first expanded.\n\n\n\n\n\n","category":"method"},{"location":"model_kit/#HomotopyContinuation2.ModelKit.differentiate","page":"ModelKit","title":"HomotopyContinuation2.ModelKit.differentiate","text":"differentiate(expr::Expression, var::Variable, k = 1)\ndifferentiate(expr::AbstractVector{Expression}, var::Variable, k = 1)\n\nCompute the k-th derivative of expr with respect to the given variable var.\n\ndifferentiate(expr::Expression, vars::AbstractVector{Variable})\n\nCompute the partial derivatives of expr with respect to the given variable variables vars. Retuns a Vector containing the partial derivatives.\n\ndifferentiate(exprs::AbstractVector{Expression}, vars::AbstractVector{Variable})\n\nCompute the partial derivatives of exprs with respect to the given variable variables vars. Returns a Matrix where the each row contains the partial derivatives for a given expression.\n\n\n\n\n\n","category":"function"},{"location":"model_kit/#HomotopyContinuation2.ModelKit.dense_poly","page":"ModelKit","title":"HomotopyContinuation2.ModelKit.dense_poly","text":"dense_poly(vars::AbstractVector{Variable}, d::Integer; homogeneous::Bool = false)\n\nCreate a dense polynomial of degree d in the given variables variables where each coefficient is a parameter. Returns a tuple with the first argument being the polynomial and the second the parameters.\n\njulia> @var x y;\n\njulia> f, c = dense_poly([x, y], 2);\n\njulia> f\nc#262₁ + x*c#262₂ + x^2*c#262₄ + y*c#262₃ + y^2*c#262₆ + x*y*c#262₅\n\njulia> c\n6-element Array{Variable,1}:\n c#262₁\n c#262₂\n c#262₃\n c#262₄\n c#262₅\n c#262₆\n\n\n\n\n\n","category":"function"},{"location":"model_kit/#HomotopyContinuation2.ModelKit.evaluate","page":"ModelKit","title":"HomotopyContinuation2.ModelKit.evaluate","text":"evaluate(expr::Expression, subs...)\nevaluate(expr::AbstractArray{Expression}, subs...)\n\nEvaluate the given expression.\n\nExample\n\njulia> @var x y;\n\njulia> evaluate(x^2, x => 2)\n4\n\njulia> evaluate(x * y, [x,y] => [2, 3])\n6\n\njulia> evaluate([x^2, x * y], [x,y] => [2, 3])\n2-element Array{Int64,1}:\n 4\n 6\n\n# You can also use the callable syntax\njulia> [x^2, x * y]([x,y] => [2, 3])\n2-element Array{Int64,1}:\n 4\n 6\n\n\n\n\n\n","category":"function"},{"location":"model_kit/#HomotopyContinuation2.ModelKit.expand","page":"ModelKit","title":"HomotopyContinuation2.ModelKit.expand","text":"expand(e::Expression)\n\nExpand a given expression.\n\njulia> @var x y\n(x, y)\n\njulia> expand((x + y) ^ 2)\n2*x*y + x^2 + y^2\n\n\n\n\n\n","category":"function"},{"location":"model_kit/#HomotopyContinuation2.ModelKit.exponents_coefficients","page":"ModelKit","title":"HomotopyContinuation2.ModelKit.exponents_coefficients","text":"exponents_coefficients(f::Expression, vars::AbstractVector{Variable}; expanded = false)\n\nReturn a matrix M containing the exponents for all occuring terms (one term per column) and a vector c containing the corresponding coefficients. Expands the given expression f unless expanded = true.\n\n\n\n\n\n","category":"function"},{"location":"model_kit/#HomotopyContinuation2.ModelKit.horner","page":"ModelKit","title":"HomotopyContinuation2.ModelKit.horner","text":"horner(f::Expression, vars = variables(f))\n\nRewrite f using a multi-variate horner schema.\n\nExample\n\njulia> @var u v c[1:3]\n(u, v, Variable[c₁, c₂, c₃])\n\njulia> f = c[1] + c[2] * v + c[3] * u^2 * v^2 + c[3]u^3 * v\nc₁ + v*c₂ + u^2*v^2*c₃ + u^3*v*c₃\n\njulia> horner(f)\nc₁ + v*(c₂ + u^3*c₃ + u^2*v*c₃)\n\n\n\n\n\n","category":"function"},{"location":"model_kit/#HomotopyContinuation2.ModelKit.nvariables-Tuple{Expression}","page":"ModelKit","title":"HomotopyContinuation2.ModelKit.nvariables","text":"nvariables(expr::Expression; parameters = Variable[])\nnvariables(exprs::AbstractVector{Expression}; parameters = Variable[])\n\nObtain the number of variables used in the given expression not counting the the ones declared in parameters.\n\n\n\n\n\n","category":"method"},{"location":"model_kit/#HomotopyContinuation2.ModelKit.monomials","page":"ModelKit","title":"HomotopyContinuation2.ModelKit.monomials","text":"monomials(variables::AbstractVector{Variable}, d::Integer; homogeneous::Bool = false)\n\nCreate all monomials of a given degree in the given variables.\n\njulia> @var x y\n(x, y)\n\njulia> monomials([x,y], 2)\n6-element Array{Expression,1}:\nx^2\nx*y\ny^2\n  x\n  y\n  1\n\njulia> monomials([x,y], 2; homogeneous = true)\n3-element Array{Operation,1}:\n x ^ 2\n x * y\n y ^ 2\n\n\n\n\n\n","category":"function"},{"location":"model_kit/#HomotopyContinuation2.ModelKit.subs","page":"ModelKit","title":"HomotopyContinuation2.ModelKit.subs","text":"subs(expr::Expression, subsitutions::Pair...)\nsubs(exprs::AbstractVector{<:Expression}, subsitutions::Pair...)\n\nApply the given substitutions to the given expressions.\n\nExamples\n\n@var x y\n\njulia> subs(x^2, x => y)\ny ^ 2\n\njulia> subs(x * y, [x,y] => [x+2,y+2])\n(x + 2) * (y + 2)\n\njulia> subs([x + y, x^2], x => y + 2, y => x + 2)\n2-element Array{Expression,1}:\n 4 + x + y\n (2 + y)^2\n\n# You can also use the callable syntax\njulia> (x * y)([x,y] => [x+2,y+2])\n (x + 2) * (y + 2)\n\n\n\n\n\n","category":"function"},{"location":"model_kit/#HomotopyContinuation2.ModelKit.rand_poly","page":"ModelKit","title":"HomotopyContinuation2.ModelKit.rand_poly","text":"rand_poly(T = ComplexF64, vars::AbstractVector{Variable}, d::Integer; homogeneous::Bool = false)\n\nCreate a random dense polynomial of degree d in the given variables variables. Each coefficient is sampled independently via randn(T).\n\njulia> @var x y;\n\njulia> rand_poly(Float64, [x, y], 2)\n0.788764085756728 - 0.534507647623108*x - 0.778441366874946*y -\n 0.128891763280247*x*y + 0.878962738754971*x^2 + 0.550480741774464*y^2\n\n\n\n\n\n","category":"function"},{"location":"model_kit/#HomotopyContinuation2.ModelKit.to_number","page":"ModelKit","title":"HomotopyContinuation2.ModelKit.to_number","text":"to_number(x::Expression)\n\nTries to unpack the Expression x to a native number type.\n\n```julia-repl julia> x = to_number(Expression(2)) 2\n\njulia> typeof(x) Int64\n\n\n\n\n\n","category":"function"},{"location":"model_kit/#HomotopyContinuation2.ModelKit.variables-Tuple{Expression}","page":"ModelKit","title":"HomotopyContinuation2.ModelKit.variables","text":"variables(expr::Expression; parameters = Variable[])\nvariables(exprs::AbstractVector{Expression}; parameters = Variable[])\n\nObtain all variables used in the given expression up to the ones declared in parameters.\n\nExample\n\njulia> @var x y a;\njulia> variables(x^2 + y)\n2-element Array{Variable,1}:\n x\n y\n\njulia> variables([x^2 + a, y]; parameters = [a])\n2-element Array{Variable,1}:\n x\n y\n\n\n\n\n\n","category":"method"},{"location":"model_kit/#System-1","page":"ModelKit","title":"System","text":"","category":"section"},{"location":"model_kit/#","page":"ModelKit","title":"ModelKit","text":"System\ndegrees(F::System)\nexpressions(F::System)\nnparameters(::System)\nnvariables(::System)\nparameters(::System)\nvariables(::System)","category":"page"},{"location":"model_kit/#HomotopyContinuation2.ModelKit.System","page":"ModelKit","title":"HomotopyContinuation2.ModelKit.System","text":"System(exprs::AbstractVector{Expression};\n            variables = variables(exprssion),\n            parameters = Variable[])\nSystem(exprs, variables; parameters = Variable[])\n\nCreate a system from the given Expressions exprs. The variables determine also the variable ordering. The parameters argument allows to declare certain Variables as parameters.\n\nExamples\n\njulia> @var x y;\njulia> F = System([x^2, y^2]; variables = [y, x])\nSystem of length 2\n 2 variables: y, x\n\n x^2\n y^2\n\n# Systems are callable.\n# This evaluates F at y=2 and x=3\njulia> F([2, 3])\n2-element Array{Int64,1}:\n 9\n 4\n\nIt is also possible to declare parameters.\n\njulia> @var x y a b;\njulia> F = System([x^2 + a, y^2 + b]; variables = [y, x], parameters = [a, b])\nSystem of length 2\n 2 variables: y, x\n 2 parameters: a, b\n\n a + x^2\n b + y^2\n\njulia> F([2, 3], [5, -2])\n 2-element Array{Int64,1}:\n  14\n   2\n\n\n\n\n\n","category":"type"},{"location":"model_kit/#HomotopyContinuation2.ModelKit.degrees-Tuple{System}","page":"ModelKit","title":"HomotopyContinuation2.ModelKit.degrees","text":"degrees(F::System)\n\nReturn the degrees of the given system.\n\n\n\n\n\n","category":"method"},{"location":"model_kit/#HomotopyContinuation2.ModelKit.expressions-Tuple{System}","page":"ModelKit","title":"HomotopyContinuation2.ModelKit.expressions","text":"expressions(F::System)\n\nReturns the expressions of the given system F.\n\n\n\n\n\n","category":"method"},{"location":"model_kit/#HomotopyContinuation2.ModelKit.nparameters-Tuple{System}","page":"ModelKit","title":"HomotopyContinuation2.ModelKit.nparameters","text":"nparameters(F::System)\n\nReturns the number of parameters of the given system F.\n\n\n\n\n\n","category":"method"},{"location":"model_kit/#HomotopyContinuation2.ModelKit.nvariables-Tuple{System}","page":"ModelKit","title":"HomotopyContinuation2.ModelKit.nvariables","text":"nvariables(F::System)\n\nReturns the number of variables of the given system F.\n\n\n\n\n\n","category":"method"},{"location":"model_kit/#HomotopyContinuation2.ModelKit.parameters-Tuple{System}","page":"ModelKit","title":"HomotopyContinuation2.ModelKit.parameters","text":"parameters(F::System)\n\nReturns the parameters of the given system F.\n\n\n\n\n\n","category":"method"},{"location":"model_kit/#HomotopyContinuation2.ModelKit.variables-Tuple{System}","page":"ModelKit","title":"HomotopyContinuation2.ModelKit.variables","text":"variables(F::System)\n\nReturns the variables of the given system F.\n\n\n\n\n\n","category":"method"},{"location":"model_kit/#Homotopy-1","page":"ModelKit","title":"Homotopy","text":"","category":"section"},{"location":"model_kit/#","page":"ModelKit","title":"ModelKit","text":"Homotopy\nexpressions(::Homotopy)\nnparameters(::Homotopy)\nnvariables(::Homotopy)\nparameters(::Homotopy)\nvariables(::Homotopy)","category":"page"},{"location":"model_kit/#HomotopyContinuation2.ModelKit.Homotopy","page":"ModelKit","title":"HomotopyContinuation2.ModelKit.Homotopy","text":"Homotopy(exprs, vars, t, parameters = Variable[])\n\nCreate a homotopy H(vars,t) from the given Expressions exprs where vars are the given variables and t is the dedicated variable parameterizing the family of systems. The parameters argument allows to declare certain Variables as parameters.\n\nExample\n\njulia> @var x y t;\n\njulia> H = Homotopy([x + t, y + 2t], [y, x], t)\nHomotopy in t of length 2\n 2 variables: y, x\n\n t + x\n 2*t + y\n\njulia> H([2, 3], 0)\n2-element Array{Int64,1}:\n 3\n 2\n\n\njulia> H([2, 3], 1)\n2-element Array{Int64,1}:\n 4\n 4\n\nIt is also possible to declare additional variables.\n\njulia> @var x y t a b;\njulia> H = Homotopy([x^2 + t*a, y^2 + t*b], [x, y], t, [a, b])\nHomotopy in t of length 2\n 2 variables: x, y\n 2 parameters: a, b\n\n a*t + x^2\n b*t + y^2\njulia> H([2, 3], 1, [5, 2])\n2-element Array{Int64,1}:\n 9\n 11\n\n\n\n\n\n","category":"type"},{"location":"model_kit/#HomotopyContinuation2.ModelKit.expressions-Tuple{Homotopy}","page":"ModelKit","title":"HomotopyContinuation2.ModelKit.expressions","text":"expressions(H::Homotopy)\n\nReturns the expressions of the given homotopy H.\n\n\n\n\n\n","category":"method"},{"location":"model_kit/#HomotopyContinuation2.ModelKit.nparameters-Tuple{Homotopy}","page":"ModelKit","title":"HomotopyContinuation2.ModelKit.nparameters","text":"nparameters(H::Homotopy)\n\nReturns the number of parameters of the given homotopy H.\n\n\n\n\n\n","category":"method"},{"location":"model_kit/#HomotopyContinuation2.ModelKit.nvariables-Tuple{Homotopy}","page":"ModelKit","title":"HomotopyContinuation2.ModelKit.nvariables","text":"nvariables(H::Homotopy)\n\nReturns the number of variables of the given homotopy H.\n\n\n\n\n\n","category":"method"},{"location":"model_kit/#HomotopyContinuation2.ModelKit.parameters-Tuple{Homotopy}","page":"ModelKit","title":"HomotopyContinuation2.ModelKit.parameters","text":"parameters(H::Homotopy)\n\nReturns the parameters of the given homotopy H.\n\n\n\n\n\n","category":"method"},{"location":"model_kit/#HomotopyContinuation2.ModelKit.variables-Tuple{Homotopy}","page":"ModelKit","title":"HomotopyContinuation2.ModelKit.variables","text":"variables(H::Homotopy)\n\nReturns the variables of the given homotopy H.\n\n\n\n\n\n","category":"method"},{"location":"systems_homotopies/#Systems-and-Homotopies-1","page":"Systems and Homotopies","title":"Systems and Homotopies","text":"","category":"section"},{"location":"systems_homotopies/#Systems-1","page":"Systems and Homotopies","title":"Systems","text":"","category":"section"},{"location":"systems_homotopies/#","page":"Systems and Homotopies","title":"Systems and Homotopies","text":"Systems (AbstractSystem) are the basic building blocks of homotopies.","category":"page"},{"location":"systems_homotopies/#","page":"Systems and Homotopies","title":"Systems and Homotopies","text":"AbstractSystem\nModelKitSystem\nRandomizedSystem","category":"page"},{"location":"systems_homotopies/#HomotopyContinuation2.AbstractSystem","page":"Systems and Homotopies","title":"HomotopyContinuation2.AbstractSystem","text":"AbstractSystem\n\nAn abstract type representing a polynomial system F(x).\n\nThe following systems are available:\n\nModelKitSystem\nRandomizedSystem\n\n\n\n\n\n","category":"type"},{"location":"systems_homotopies/#HomotopyContinuation2.ModelKitSystem","page":"Systems and Homotopies","title":"HomotopyContinuation2.ModelKitSystem","text":"ModelKitSystem(F:System, parameters = nothing)\n\nConstruct a system from the given System F with the given parameters fixed. The difference to F is that this compiles a straight line programm for the fast evaluation of F and that ModelKitSystem <: AbstractSystem.\n\n\n\n\n\n","category":"type"},{"location":"systems_homotopies/#HomotopyContinuation2.RandomizedSystem","page":"Systems and Homotopies","title":"HomotopyContinuation2.RandomizedSystem","text":"RandomizedSystem(F::Union{System,AbstractSystem}, k::Integer) <: AbstractSystem\n\nGiven a n  N system F with n  N this constructs the system mathfrakR(F k)(x) = I AF(x) where I is a k  k identity matrix and A is random complex k  n matrix. See Chapter 13.5 in [SW05] for more details.\n\nRandomizedSystem(F::Union{System,AbstractSystem}, A::Matrix{ComplexF64}) <: AbstractSystem\n\nExplicitly provide the used randomization matrix A.\n\n[SW05]: Sommese, A. J., & Wampler, C. W. (2005). The Numerical Solution of Systems of Polynomials Arising in Engineering and Science. World Scientific.\n\n\n\n\n\n","category":"type"},{"location":"systems_homotopies/#Homotopies-1","page":"Systems and Homotopies","title":"Homotopies","text":"","category":"section"},{"location":"systems_homotopies/#","page":"Systems and Homotopies","title":"Systems and Homotopies","text":"Homotopies (AbstractHomotopy) are at the heart of homotopy continuation. A homotopy is a parameterized family H(xt) of polynomial systems. By convention, homotopies are tracked from t=1 to t=0, i.e., H(x1) is considered the start system and H(x0) is the target system.","category":"page"},{"location":"systems_homotopies/#","page":"Systems and Homotopies","title":"Systems and Homotopies","text":"AbstractHomotopy\nAffineChartHomotopy\non_affine_chart\nAffineSubspaceHomotopy\nset_subspaces!\nModelKitHomotopy\nParameterHomotopy\nStraightLineHomotopy","category":"page"},{"location":"systems_homotopies/#HomotopyContinuation2.AbstractHomotopy","page":"Systems and Homotopies","title":"HomotopyContinuation2.AbstractHomotopy","text":"AbstractHomotopy\n\nAn abstract type representing a homotopy H(xt).\n\nThe following homotopies are available:\n\nAffineChartHomotopy\nAffineSubspaceHomotopy\nModelKitHomotopy\nParameterHomotopy\nStraightLineHomotopy\n\n\n\n\n\n","category":"type"},{"location":"systems_homotopies/#HomotopyContinuation2.AffineChartHomotopy","page":"Systems and Homotopies","title":"HomotopyContinuation2.AffineChartHomotopy","text":"AffineChartHomotopy(H::AbstractHomotopy, v::PVector{T,N})\n\nGiven a homotopy H(xt) (ℙ^m_1    ℙ^m_N)  ℂ  ℂⁿ this creates a new affine homotopy H which operates on the affine chart defined by the vector v  ℙ^m_1    ℙ^m_N and the augmented conditions vᵀx = 1.\n\n\n\n\n\n","category":"type"},{"location":"systems_homotopies/#HomotopyContinuation2.on_affine_chart","page":"Systems and Homotopies","title":"HomotopyContinuation2.on_affine_chart","text":"on_affine_chart(H::AbstractHomotopy, proj_dims::NTuple{N,Int}) where {N}\n\nConstruct an AffineChartHomotopy on a randomly generated chart v. Each entry is drawn idepdently from a univariate normal distribution.\n\n\n\n\n\n","category":"function"},{"location":"systems_homotopies/#HomotopyContinuation2.AffineSubspaceHomotopy","page":"Systems and Homotopies","title":"HomotopyContinuation2.AffineSubspaceHomotopy","text":"AffineSubspaceHomotopy(F::System, V::AffineSubspace, W::AffineSubspace)\nAffineSubspaceHomotopy(F::AbstractSystem, V::AffineSubspace, W::AffineSubspace)\n\nCreates a homotopy H(xt) = (F  γ(t))(x) where γ(t) is a family of affine subspaces such that H(x1) = (F  V)(x) and H(x0) = (F  W)(x). Here γ(t) is the geodesic between V and W in the affine Grassmanian, i.e., it is the curve of minimal length connecting V and W. See also AffineSubspace and geodesic and the references therein.\n\n\n\n\n\n","category":"type"},{"location":"systems_homotopies/#HomotopyContinuation2.set_subspaces!","page":"Systems and Homotopies","title":"HomotopyContinuation2.set_subspaces!","text":"set_subspaces!(H::AffineSubspaceHomotopy, start::AffineSubspace, target::AffineSubspace)\n\nUpdate the homotopy H to track from the affine subspace start to target.\n\n\n\n\n\n","category":"function"},{"location":"systems_homotopies/#HomotopyContinuation2.ModelKitHomotopy","page":"Systems and Homotopies","title":"HomotopyContinuation2.ModelKitHomotopy","text":"ModelKitHomotopy(H::Homotopy, parameters = nothing)\n\nConstruct a homotopy from the given homotopy H with the given parameters fixed. The difference to H is that this compiles a straight line programm for the fast evaluation of H and that ModelKitHomotopy <: AbstractHomotopy.\n\n\n\n\n\n","category":"type"},{"location":"systems_homotopies/#HomotopyContinuation2.ParameterHomotopy","page":"Systems and Homotopies","title":"HomotopyContinuation2.ParameterHomotopy","text":"ParameterHomotopy(F::Union{AbstractSystem,System}; start_parameters, target_parameters)\nParameterHomotopy(F::Union{AbstractSystem,System}, start_parameters, target_parameters)\n\nConstruct the parameter homotopy H(xt) = F(x t p + (1 - t) q) where p is start_parameters and q is target_parameters.\n\n\n\n\n\n","category":"type"},{"location":"systems_homotopies/#HomotopyContinuation2.StraightLineHomotopy","page":"Systems and Homotopies","title":"HomotopyContinuation2.StraightLineHomotopy","text":"StraightLineHomotopy(G::System, F::System)\nStraightLineHomotopy(G::AbstractSystem, F::AbstractSystem)\n\nConstructs the straight line homotopy H(x t) = tG(x) + (1-t)F(x).\n\n\n\n\n\n","category":"type"},{"location":"misc/#Miscellaneous-1","page":"Miscellaneous","title":"Miscellaneous","text":"","category":"section"},{"location":"misc/#Newton's-method-1","page":"Miscellaneous","title":"Newton's method","text":"","category":"section"},{"location":"misc/#","page":"Miscellaneous","title":"Miscellaneous","text":"newton\nNewtonResult\nis_success(::NewtonResult)\nNewtonCache","category":"page"},{"location":"misc/#HomotopyContinuation2.newton","page":"Miscellaneous","title":"HomotopyContinuation2.newton","text":"newton(\n    F::AbstractSystem,\n    x₀::AbstractVector,\n    norm::AbstractNorm = InfNorm(),\n    cache::NewtonCache = NewtonCache(F, x₀);\n    options...\n)\n\nAn implemenetation of a local Newton's method with various options to specify convergence criteria. Returns a NewtonResult. The computations are always performed in complex arithmetic with double precision, i.e., using Complex{Float64}. The optional cache argument pre-allocates the necessary memory. This is useful if the method is called repeatedly.\n\nOptions\n\nabs_tol::Float64 = 1e-8: The method is declared converged if norm(xᵢ₊₁ - xᵢ) < abs_tol.\nrel_tol::Float64 = abs_tol: The method is declared converged if norm(xᵢ₊₁ - xᵢ) < abs_tol * norm(x₀).\nmax_iters::Int = 20: The maximal number of iterations.\nextended_precision::Bool = false: An optional use of extended precision for the evaluation of F(x). This can increase the achievable accuracy.\ncontraction_factor::Float64 = 1.0: The Newton updates have to satisfy xᵢ₁ - xᵢ  a^2^(i-1)x₁ - x₀ for i  1 where a is contraction_factor.\nmin_contraction_iters::Int = typemax(Int):  The minimal number of iterations the contraction_factor has to be satisfied. If after min_contraction_iters many iterations the contraction factor is not satisfied the step is accepted anyway.\nmax_abs_norm_first_update::Float64 = Inf: The initial guess x₀ is rejected if norm(x₁ - x₀) >  max_abs_norm_first_update\nmax_rel_norm_first_update::Float64 = max_abs_norm_first_update: The initial guess x₀ is rejected if norm(x₁ - x₀) >  max_rel_norm_first_update * norm(x₀)\n\n\n\n\n\n","category":"function"},{"location":"misc/#HomotopyContinuation2.NewtonResult","page":"Miscellaneous","title":"HomotopyContinuation2.NewtonResult","text":"NewtonResult\n\nResult returned by newton.\n\nFields\n\nreturn_code::Symbol: Can be :success, :rejected or :max_iters.\nx::Vector{ComplexF64}: The last value obtained.\naccuracy::Float64: Estimate of the distance of x to a true zero.\niters::Int Number of iterations performed.\ncontraction_ratio::Float64: The value |xᵢ - xᵢ₋₁| / |xᵢ₋₁ - xᵢ₋₂|.\n\n\n\n\n\n","category":"type"},{"location":"misc/#HomotopyContinuation2.is_success-Tuple{NewtonResult}","page":"Miscellaneous","title":"HomotopyContinuation2.is_success","text":"is_success(R::NewtonResult)\n\nReturns true if the newton was successfull.\n\n\n\n\n\n","category":"method"},{"location":"misc/#HomotopyContinuation2.NewtonCache","page":"Miscellaneous","title":"HomotopyContinuation2.NewtonCache","text":"NewtonCache(F::AbstractSystem)\n\nPre-allocates the necessary memory for newton.\n\n\n\n\n\n","category":"type"},{"location":"misc/#Norms-1","page":"Miscellaneous","title":"Norms","text":"","category":"section"},{"location":"misc/#","page":"Miscellaneous","title":"Miscellaneous","text":"AbstractNorm\nInfNorm\nWeightedNorm\ndistance(u, v, ::AbstractNorm)\nnorm(u, ::AbstractNorm)\ninit!(::WeightedNorm, ::AbstractVector)\nupdate!(::WeightedNorm, ::AbstractVector)","category":"page"},{"location":"misc/#HomotopyContinuation2.AbstractNorm","page":"Miscellaneous","title":"HomotopyContinuation2.AbstractNorm","text":"AbstractNorm\n\nAn AbstractNorm represents any norm of a vector space. All norms are callable. norm(x) computes the norm of x and norm(x,y) computes the distance norm(x - y).\n\n\n\n\n\n","category":"type"},{"location":"misc/#HomotopyContinuation2.InfNorm","page":"Miscellaneous","title":"HomotopyContinuation2.InfNorm","text":"InfNorm <: AbstractNorm\n\nThe infinity or maximum norm.\n\n\n\n\n\n","category":"type"},{"location":"misc/#HomotopyContinuation2.WeightedNorm","page":"Miscellaneous","title":"HomotopyContinuation2.WeightedNorm","text":"WeightedNorm(d::AbstractVector, norm::AbstractNorm; options...)\nWeightedNorm(norm::AbstractNorm, n::Integer; options...)\nWeightedNorm(norm::AbstractNorm, x::AbstractVector; options...)\n\nA WeightedNorm represents a weighted variant of norm norm of a n-dimensional vector space.A norm||x||is weighted by introducing a vector of additional weightsdsuch that the new norm is||D⁻¹x||whereDis the diagonal matrix with diagonald. The WeightedNorm is desigened to change the weights dynamically by using init!(::WeightedNorm, x) and update!(::WeightedNorm, x). The weights are there constructed such that D¹x  10. The weights can be accessed and changed by indexing.\n\nOptions\n\nscale_min = sqrt(eps()): The minimal size of dᵢ is scale_min time the (weighted) norm of x.\nscale_abs_min = min(scale_min^2, 200 * sqrt(eps())): The absolute minimal size of dᵢ.\nscale_max = 1.0 / eps() / sqrt(2): The absolute maximal size of dᵢ\n\n\n\n\n\n","category":"type"},{"location":"misc/#HomotopyContinuation2.distance-Tuple{Any,Any,AbstractNorm}","page":"Miscellaneous","title":"HomotopyContinuation2.distance","text":"distance(u, v, norm::AbstractNorm)\n\nCompute the distance ||u-v|| with respect to the given norm norm.\n\n\n\n\n\n","category":"method"},{"location":"misc/#LinearAlgebra.norm-Tuple{Any,AbstractNorm}","page":"Miscellaneous","title":"LinearAlgebra.norm","text":"norm(u, norm::AbstractNorm)\n\nCompute the norm ||u|| with respect to the given norm norm.\n\n\n\n\n\n","category":"method"},{"location":"misc/#HomotopyContinuation2.init!-Tuple{WeightedNorm,AbstractArray{T,1} where T}","page":"Miscellaneous","title":"HomotopyContinuation2.init!","text":"init!(w::WeightedNorm, x::AbstractVector)\n\nSetup the weighted norm w for x.\n\n\n\n\n\n","category":"method"},{"location":"misc/#HomotopyContinuation2.update!-Tuple{WeightedNorm,AbstractArray{T,1} where T}","page":"Miscellaneous","title":"HomotopyContinuation2.update!","text":"update!(w::WeightedNorm, x::AbstractVector)\n\nUpdate the weighted norm w for x, this will interpolate between the previous weights and the norm of x.\n\n\n\n\n\n","category":"method"},{"location":"misc/#Debugging-1","page":"Miscellaneous","title":"Debugging","text":"","category":"section"},{"location":"misc/#","page":"Miscellaneous","title":"Miscellaneous","text":"path_info","category":"page"},{"location":"misc/#HomotopyContinuation2.path_info","page":"Miscellaneous","title":"HomotopyContinuation2.path_info","text":"path_info(tracker::Tracker, x₀, t₁ = 1.0, t₀ = 0.0; debug::Bool = false, kwargs...)\n\nTrack a path using the given tracker and start value x₀. This returns a struct containing detailed information about the tracked path.\n\n\n\n\n\n","category":"function"},{"location":"#Introduction-1","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"HomotopyContinuation.jl is a package for the numerical solution of systems of polynomial equations.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"This documentation is a purely technical description of the package functionality. You can find tutorials, examples, how-to guides and explanations on our homepage JuliaHomotopyContinuation.org.","category":"page"},{"location":"#Contents-1","page":"Introduction","title":"Contents","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"Pages = [\n    \"model_kit.md\",\n    \"linear_affine.md\",\n    \"systems_homotopies.md\",\n    \"misc.md\"\n]\nDepth = 2","category":"page"}]
}
