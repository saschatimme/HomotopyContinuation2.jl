var documenterSearchIndex = {"docs":
[{"location":"linear_affine/#Linear-and-Affine-Subspaces-1","page":"Linear and Affine Subspaces","title":"Linear and Affine Subspaces","text":"","category":"section"},{"location":"linear_affine/#","page":"Linear and Affine Subspaces","title":"Linear and Affine Subspaces","text":"We provide built-in data structures to work with affine and linear subspaces L. L can be represented in either extrinsic coordinates x with L = x  Ax = b  or in intrinsic coordinates u with L=Bu+p  u.","category":"page"},{"location":"linear_affine/#Coordinates-1","page":"Linear and Affine Subspaces","title":"Coordinates","text":"","category":"section"},{"location":"linear_affine/#","page":"Linear and Affine Subspaces","title":"Linear and Affine Subspaces","text":"To specify which coordinates are given / expected the following can be used:","category":"page"},{"location":"linear_affine/#","page":"Linear and Affine Subspaces","title":"Linear and Affine Subspaces","text":"Coordinates\nIntrinsic\nExtrinsic","category":"page"},{"location":"linear_affine/#HomotopyContinuation2.Coordinates","page":"Linear and Affine Subspaces","title":"HomotopyContinuation2.Coordinates","text":"Coordinates\n\nA type used for encoding the used coordinates and for performing coordinate changes.\n\nCurrently supported coordinates are:\n\nIntrinsic\nExtrinsic\n\n\n\n\n\n","category":"type"},{"location":"linear_affine/#HomotopyContinuation2.Intrinsic","page":"Linear and Affine Subspaces","title":"HomotopyContinuation2.Intrinsic","text":"Intrinsic <: Coordinates\n\nIndicates the use of the intrinsic description of an affine subspace. See also AffineIntrinsic.\n\n\n\n\n\n","category":"constant"},{"location":"linear_affine/#HomotopyContinuation2.Extrinsic","page":"Linear and Affine Subspaces","title":"HomotopyContinuation2.Extrinsic","text":"Extrinsic <: Coordinates\n\nIndicates the use of the extrinsic description of an affine subspace. See also AffineExtrinsic.\n\n\n\n\n\n","category":"constant"},{"location":"linear_affine/#Affine-Subspace-1","page":"Linear and Affine Subspaces","title":"Affine Subspace","text":"","category":"section"},{"location":"linear_affine/#","page":"Linear and Affine Subspaces","title":"Linear and Affine Subspaces","text":"AffineSubspace\nAffineExtrinsic\nAffineIntrinsic","category":"page"},{"location":"linear_affine/#HomotopyContinuation2.AffineSubspace","page":"Linear and Affine Subspaces","title":"HomotopyContinuation2.AffineSubspace","text":"AffineSubspace(A, b)\n\nAn m-dimensional affine subspace L in n-dimensional space given by the extrinsic description L =  x  A x = b .\n\njulia> A = AffineSubspace([1 0 3; 2 1 3], [5, -2])\n1-dim. affine subspace {x|Ax=b} with eltype Float64:\nA:\n2×3 Array{Float64,2}:\n 1.0  0.0  3.0\n 2.0  1.0  3.0\nb:\n2-element Array{Float64,1}:\n  5.0\n -2.0\n\njulia> dim(A)\n1\n\njulia> codim(A)\n2\n\njulia> ambient_dim(A)\n3\n\nAn AffineSubspace holds always its extrinsic description, see also AffineIntrinsic, as well as its intrinsic description, see AffineExtrinsic.\n\njulia> intrinsic(A)\nAffineIntrinsic{Float64}:\nA:\n3×1 Array{Float64,2}:\n -0.6882472016116853\n  0.6882472016116853\n  0.22941573387056186\nb₀:\n3-element Array{Float64,1}:\n -3.0526315789473677\n -3.947368421052632\n  2.684210526315789\n\nAn AffineSubspace can be evaluated with either using Intrinsic or Extrinsic coordinates.\n\njulia> u = [0.5]\n1-element Array{Float64,1}:\n 0.5\n\njulia> x = A(u, Intrinsic)\n3-element Array{Float64,1}:\n -3.3967551797532103\n -3.6032448202467893\n  2.79891839325107\n\njulia> A(x, Extrinsic)\n  2-element Array{Float64,1}:\n   0.0\n   0.0\n\nTo change the used coordinates you can use coord_change.\n\njulia> coord_change(A, Extrinsic, Intrinsic, x)\n1-element Array{Float64,1}:\n 0.49999999999999994\n\n\n\n\n\n","category":"type"},{"location":"linear_affine/#HomotopyContinuation2.AffineExtrinsic","page":"Linear and Affine Subspaces","title":"HomotopyContinuation2.AffineExtrinsic","text":"AffineExtrinsic\n\nExtrinsic description of an m-dimensional affine subspace L in n-dimensional space. That is L =  x  A x = b .\n\n\n\n\n\n","category":"type"},{"location":"linear_affine/#HomotopyContinuation2.AffineIntrinsic","page":"Linear and Affine Subspaces","title":"HomotopyContinuation2.AffineIntrinsic","text":"AffineIntrinsic\n\nIntrinsic description of an m-dimensional affine subspace L in n-dimensional space. That is L =  u  A u + b₀ . Here, A and b₀ are in orthogonal coordinates. That is, the columns of A are orthonormal and A b₀ = 0.\n\n\n\n\n\n","category":"type"},{"location":"linear_affine/#Functions-1","page":"Linear and Affine Subspaces","title":"Functions","text":"","category":"section"},{"location":"linear_affine/#","page":"Linear and Affine Subspaces","title":"Linear and Affine Subspaces","text":"ambient_dim\ncodim\ncoord_change\ndim\nintrinsic\nextrinsic\ngeodesic\ngeodesic_distance\nrand_affine_subspace","category":"page"},{"location":"linear_affine/#HomotopyContinuation2.ambient_dim","page":"Linear and Affine Subspaces","title":"HomotopyContinuation2.ambient_dim","text":"ambient_dim(A::AffineSubspace)\n\nDimension of ambient space of the affine subspace A.\n\n\n\n\n\n","category":"function"},{"location":"linear_affine/#HomotopyContinuation2.codim","page":"Linear and Affine Subspaces","title":"HomotopyContinuation2.codim","text":"codim(A::AffineExtrinsic)\n\nCodimension of the affine subspace A.\n\n\n\n\n\ncodim(A::AffineIntrinsic)\n\nCodimension of the affine subspace A.\n\n\n\n\n\ncodim(A::AffineSubspace)\n\nCodimension of the affine subspace A.\n\n\n\n\n\n","category":"function"},{"location":"linear_affine/#HomotopyContinuation2.coord_change","page":"Linear and Affine Subspaces","title":"HomotopyContinuation2.coord_change","text":"coord_change(A::AffineSubspace, C₁::Coordinates, C₂::Coordinates, p)\n\nGiven an affine subspace A and a point p in coordinates C₁ compute the point x describing p in coordinates C₂.\n\nExample\n\njulia> A = AffineSubspace([1 0 3; 2 1 3], [5, -2]);\n\njulia> u = [1.25];\n\njulia> x = coord_change(A, Intrinsic, Extrinsic, u)\n3-element Array{Float64,1}:\n -3.9129405809619744\n -3.087059419038025\n  2.9709801936539915\n\njulia> A(x, Extrinsic)\n2-element Array{Float64,1}:\n 0.0\n 0.0\n\njulia> x - A(u, Intrinsic)\n3-element Array{Float64,1}:\n 0.0\n 0.0\n 0.0\n\n\n\n\n\n","category":"function"},{"location":"linear_affine/#HomotopyContinuation2.dim","page":"Linear and Affine Subspaces","title":"HomotopyContinuation2.dim","text":"dim(A::AffineExtrinsic)\n\nDimension of the affine subspace A.\n\n\n\n\n\ndim(A::AffineIntrinsic)\n\nDimension of the affine subspace A.\n\n\n\n\n\ndim(A::AffineSubspace)\n\nDimension of the affine subspace A.\n\n\n\n\n\n","category":"function"},{"location":"linear_affine/#HomotopyContinuation2.intrinsic","page":"Linear and Affine Subspaces","title":"HomotopyContinuation2.intrinsic","text":"intrinsic(A::AffineSubspace)\n\nObtain the intrinsic description of A, see also AffineIntrinsic.\n\n\n\n\n\n","category":"function"},{"location":"linear_affine/#HomotopyContinuation2.extrinsic","page":"Linear and Affine Subspaces","title":"HomotopyContinuation2.extrinsic","text":"extrinsic(A::AffineSubspace)\n\nObtain the extrinsic description of A, see also AffineExtrinsic.\n\n\n\n\n\n","category":"function"},{"location":"linear_affine/#HomotopyContinuation2.geodesic","page":"Linear and Affine Subspaces","title":"HomotopyContinuation2.geodesic","text":"geodesic(A::AffineSubspace, B::AffineSubspace)\n\nReturns the geodesic γ(t) connecting A and B in the Grassmanian Gr(k+1n+1) where k is the dimension of A and n is the ambient dimension. See also Corollary 4.3 in [LKK19].\n\n[LKK19]: Lim, Lek-Heng, Ken Sze-Wai Wong, and Ke Ye. \"Numerical algorithms on the affine Grassmannian.\" SIAM Journal on Matrix Analysis and Applications 40.2 (2019): 371-393\n\n\n\n\n\n","category":"function"},{"location":"linear_affine/#HomotopyContinuation2.geodesic_distance","page":"Linear and Affine Subspaces","title":"HomotopyContinuation2.geodesic_distance","text":"geodesic_distance(A::AffineSubspace, B::AffineSubspace)\n\nCompute the geodesic distance between A and B in the affine Grassmanian Graff(k, n) where k = dim(A) and n is the amebient dimension. This follows the derivation in [LKK19].\n\n[LKK19]: Lim, Lek-Heng, Ken Sze-Wai Wong, and Ke Ye. \"Numerical algorithms on the affine Grassmannian.\" SIAM Journal on Matrix Analysis and Applications 40.2 (2019): 371-393.\n\n\n\n\n\n","category":"function"},{"location":"linear_affine/#HomotopyContinuation2.rand_affine_subspace","page":"Linear and Affine Subspaces","title":"HomotopyContinuation2.rand_affine_subspace","text":"rand_affine_subspace(n::Integer; dim | codim, real = false)\n\nGenerate a random AffineSubspace with given dimension dim or codimension codim (one of them has to be provided) in ambient space of dimension n. If real is true, then the extrinsic description is real. The subspace is generated by drawing each entry of the extrinsic description indepdently from a normal distribuation using randn.\n\nExample\n\njulia> rand_affine_subspace(3; dim = 1)\n1-dim. affine subspace {x|Ax=b} with eltype Complex{Float64}:\nA:\n2×3 Array{Complex{Float64},2}:\n  -1.73825+1.27987im   -0.0871343+0.840408im  -0.551957+0.106397im\n -0.597132-0.343965im   -0.122543-0.172715im   -1.04949+0.370917im\nb:\n2-element Array{Complex{Float64},1}:\n  0.47083334430689394 + 0.8099804422599071im\n -0.12018696822943896 + 0.11723026326952792im\n\njulia> rand_affine_subspace(4; codim = 1)\n3-dim. affine subspace {x|Ax=b} with eltype Complex{Float64}:\nA:\n1×4 Array{Complex{Float64},2}:\n 0.345705+0.0893881im  -0.430867-0.663249im  0.979969-0.569378im  -0.29722-0.192493im\nb:\n1-element Array{Complex{Float64},1}:\n 0.7749708228192062 + 0.9762873764567546im\n\n\n\n\n\n","category":"function"},{"location":"path_tracker/#PathTracker-1","page":"PathTracker","title":"PathTracker","text":"","category":"section"},{"location":"path_tracker/#","page":"PathTracker","title":"PathTracker","text":"PathTracker is a data structure to track for a given AbstractHomotopy H(xt) a solution x from t₁  0 to 0, i.e.,  H(xt₁) = 0 and x with H(x0) = 0 is returned. This is done by following an implicitly defined path x(t) using Tracker. In contrast to Tracker this uses an endgame to handle diverging paths and singular solutions.","category":"page"},{"location":"path_tracker/#","page":"PathTracker","title":"PathTracker","text":"AbstractPathTracker","category":"page"},{"location":"path_tracker/#HomotopyContinuation2.AbstractPathTracker","page":"PathTracker","title":"HomotopyContinuation2.AbstractPathTracker","text":"AbstractPathTracker\n\nSupertype for path trackers.\n\n\n\n\n\n","category":"type"},{"location":"path_tracker/#Constructor-and-Options-1","page":"PathTracker","title":"Constructor and Options","text":"","category":"section"},{"location":"path_tracker/#","page":"PathTracker","title":"PathTracker","text":"PathTracker\nPathTrackerOptions","category":"page"},{"location":"path_tracker/#HomotopyContinuation2.PathTracker","page":"PathTracker","title":"HomotopyContinuation2.PathTracker","text":"PathTracker(tracker::Tracker; options = PathTrackerOptions())\nPathTracker(H::AbstractHomotopy; options = PathTrackerOptions())\n\nA PathTracker combines a Tracker with an endgame. That is, while a Tracker assumes that the solution path is non-singular and convergent, the endgame allows to handle singular endpoints as well as diverging paths. To compute singular solutions the Cauchy endgame used, for divering paths a strategy based on the valuation of local Puiseux series expansion of the path is used. See [BT20] for a detailed description. By convention, a PathTracker always tracks from t=1 to t = 0. See PathTrackerOptions for the possible options.\n\n[BT20]: Breiding, P. and Timme, S. \"Tropical Endgame\", In preparation (2020)\n\n\n\n\n\n","category":"type"},{"location":"path_tracker/#HomotopyContinuation2.PathTrackerOptions","page":"PathTracker","title":"HomotopyContinuation2.PathTrackerOptions","text":"PathTrackerOptions(; options...)\n\nOptions controlling the behaviour of a PathTracker.\n\nOptions\n\nendgame_start::Float64 = 0.1: The point t in time where the endgame starts.\n\nEndgame parameters\n\nThese parameters control the behaviour during the endgame. See [BT20] for details.\n\nmin_cond::Float64 = 1e6: The minimal growth of the condition number after which an endgame strategy is considered to be applied.\nmin_growth::Float64 = 100: The minimal relative growth of a coordinate necessary to to be considered going to infininity (resp. zero).\nat_infinity_check::Bool = true: Whether divering paths should be truncated.\nzero_is_at_infinity::Bool = false: Whether paths going to a solution where at least one coordinates is zero should also be considered diverging.\nval_finite_tol::Float64 = 1e-2: Tolerance on the valuation which has to be satisfied before the Cauchy endgame is started.\nmax_winding_number::Int = 20: The maximal winding number which is attempted in the Cauchy endgame.\nval_at_infinity_tol::Float64 = 1e-3: Tolerance on the valuation which has to be satisfied before a path is considered to diverge / go to infinity.\n\n[BT20]: Breiding, P. and Timme, S. \"Tropical Endgame\", In preparation (2020)\n\n\n\n\n\n","category":"type"},{"location":"path_tracker/#Tracking-1","page":"PathTracker","title":"Tracking","text":"","category":"section"},{"location":"path_tracker/#","page":"PathTracker","title":"PathTracker","text":"track(::PathTracker, ::AbstractVector, ::Real)","category":"page"},{"location":"path_tracker/#HomotopyContinuation2.track-Tuple{PathTracker,AbstractArray{T,1} where T,Real}","page":"PathTracker","title":"HomotopyContinuation2.track","text":"track(path_tracker::PathTracker, x::AbstractVector, t::Real = 1.0;\n      path_number = nothing, debug = false)\n\nTrack the given start solution x from t towards 0 using the given path_tracker. Returns a PathResult.\n\ntrack(path_tracker::PathTracker, r::PathResult, t::Real = 1.0;\n      path_number = nothing, debug = false)\n\nTrack solution(r) from t towards 0 using the given path_tracker.\n\n\n\n\n\n","category":"method"},{"location":"model_kit/#ModelKit-1","page":"ModelKit","title":"ModelKit","text":"","category":"section"},{"location":"model_kit/#","page":"ModelKit","title":"ModelKit","text":"ModelKit is the symbolic input and modeling language of HomotopyContinuation.jl. It is designed such that you can easily create an efficient formulation of your problem.","category":"page"},{"location":"model_kit/#Expressions-and-Variables-1","page":"ModelKit","title":"Expressions and Variables","text":"","category":"section"},{"location":"model_kit/#","page":"ModelKit","title":"ModelKit","text":"Expression\nVariable\n@var\n@unique_var","category":"page"},{"location":"model_kit/#HomotopyContinuation2.ModelKit.Expression","page":"ModelKit","title":"HomotopyContinuation2.ModelKit.Expression","text":"Expression <: Number\n\nA symbolic expression.\n\njulia> expr = (Variable(:x) + 1)^2\n(1 + x)^2\n\njulia> Expression(2)\n2\n\njulia> Expression(Variable(:x))\nx\n\n\n\n\n\n","category":"type"},{"location":"model_kit/#HomotopyContinuation2.ModelKit.Variable","page":"ModelKit","title":"HomotopyContinuation2.ModelKit.Variable","text":"Variable(name::Union{String,Symbol}, indices...) <: Number\n\nA data structure representing a variable.\n\njulia> Variable(:a)\na\n\njulia> Variable(:x, 1)\nx₁\n\njulia> Variable(:x, 10, 5)\nx₁₀₋₅\n\nEquality and ordering\n\nVariables are identified by their name and indices. That is, two variables are equal if and only if they have the same name and indices.\n\njulia> Variable(:a) == Variable(:a)\ntrue\n\njulia> Variable(:a, 1) == Variable(:a, 2)\nfalse\n\nSimilarly, variables are first ordered lexicographically by their name and then by their indices.\n\njulia> Variable(:a, 1) < Variable(:a, 2)\ntrue\n\njulia> Variable(:a, 1) < Variable(:b, 1)\ntrue\n\njulia> a = [Variable(:a, i, j) for i in 1:2, j in 1:2]\n2×2 Array{Variable,2}:\n a₁₋₁  a₁₋₂\n a₂₋₁  a₂₋₂\n\njulia> sort(vec(a))\n4-element Array{Variable,1}:\n a₁₋₁\n a₂₋₁\n a₁₋₂\n a₂₋₂\n\n\n\n\n\n","category":"type"},{"location":"model_kit/#HomotopyContinuation2.ModelKit.@var","page":"ModelKit","title":"HomotopyContinuation2.ModelKit.@var","text":"@var variable1 variable2 ...\n\nDeclare variables with the given names and automatically create the variable bindings. The macro supports indexing notation to create Arrays of variables.\n\nExamples\n\njulia> @var a b x[1:2] y[1:2,1:3]\n(a, b, Variable[x₁, x₂], Variable[y₁₋₁ y₁₋₂ y₁₋₃; y₂₋₁ y₂₋₂ y₂₋₃])\n\njulia> a\na\n\njulia> b\nb\n\njulia> x\n2-element Array{Variable,1}:\n x₁\n x₂\n\njulia> y\n2×3 Array{Variable,2}:\n y₁₋₁  y₁₋₂  y₁₋₃\n y₂₋₁  y₂₋₂  y₂₋₃\n\n\n\n\n\n","category":"macro"},{"location":"model_kit/#HomotopyContinuation2.ModelKit.@unique_var","page":"ModelKit","title":"HomotopyContinuation2.ModelKit.@unique_var","text":"@unique_var variable1 variable2\n\nThis is similar to @var with the only difference that the macro automatically changes the names of the variables to ensure uniqueness. However, the binding is still to the declared name. This is useful to ensure that there are no name collisions.\n\nExamples\n\njulia> @unique_var a b\n(a#591, b#592)\n\njulia> a\na#591\n\njulia> b\nb#592\n\n\n\n\n\n","category":"macro"},{"location":"model_kit/#Methods-1","page":"ModelKit","title":"Methods","text":"","category":"section"},{"location":"model_kit/#","page":"ModelKit","title":"ModelKit","text":"coefficients\ndegree\ndegrees(::AbstractVector{Expression})\ndifferentiate\ndense_poly\nevaluate\nexpand\nexponents_coefficients\nhorner\nnvariables(::Expression)\nmonomials\nsubs\nrand_poly\nto_dict\nto_number\nvariables(::Expression)","category":"page"},{"location":"model_kit/#HomotopyContinuation2.ModelKit.coefficients","page":"ModelKit","title":"HomotopyContinuation2.ModelKit.coefficients","text":"coefficients(f::Expression, vars::AbstractVector{Variable})\n\nReturn all coefficients of the given polynomial f for the given variables vars. This assumes that the expression f is already expanded, e.g., with expand.\n\n\n\n\n\n","category":"function"},{"location":"model_kit/#HomotopyContinuation2.ModelKit.degree","page":"ModelKit","title":"HomotopyContinuation2.ModelKit.degree","text":"degree(f::Expression, vars = variables(f); expanded = false)\n\nCompute the degree of the expression f  in vars. Unless expanded is true the expression is first expanded.\n\n\n\n\n\n","category":"function"},{"location":"model_kit/#HomotopyContinuation2.ModelKit.degrees-Tuple{AbstractArray{Expression,1}}","page":"ModelKit","title":"HomotopyContinuation2.ModelKit.degrees","text":"degrees(f::AbstractVector{Expression}, vars = variables(f); expanded = false)\n\nCompute the degrees of the expressions f in vars. Unless expanded is true the expressions are first expanded.\n\n\n\n\n\n","category":"method"},{"location":"model_kit/#HomotopyContinuation2.ModelKit.differentiate","page":"ModelKit","title":"HomotopyContinuation2.ModelKit.differentiate","text":"differentiate(expr::Expression, var::Variable, k = 1)\ndifferentiate(expr::AbstractVector{Expression}, var::Variable, k = 1)\n\nCompute the k-th derivative of expr with respect to the given variable var.\n\ndifferentiate(expr::Expression, vars::AbstractVector{Variable})\n\nCompute the partial derivatives of expr with respect to the given variable variables vars. Retuns a Vector containing the partial derivatives.\n\ndifferentiate(exprs::AbstractVector{Expression}, vars::AbstractVector{Variable})\n\nCompute the partial derivatives of exprs with respect to the given variable variables vars. Returns a Matrix where the each row contains the partial derivatives for a given expression.\n\n\n\n\n\n","category":"function"},{"location":"model_kit/#HomotopyContinuation2.ModelKit.dense_poly","page":"ModelKit","title":"HomotopyContinuation2.ModelKit.dense_poly","text":"dense_poly(vars::AbstractVector{Variable}, d::Integer; homogeneous::Bool = false)\n\nCreate a dense polynomial of degree d in the given variables variables where each coefficient is a parameter. Returns a tuple with the first argument being the polynomial and the second the parameters.\n\njulia> @var x y;\n\njulia> f, c = dense_poly([x, y], 2);\n\njulia> f\nc#262₁ + x*c#262₂ + x^2*c#262₄ + y*c#262₃ + y^2*c#262₆ + x*y*c#262₅\n\njulia> c\n6-element Array{Variable,1}:\n c#262₁\n c#262₂\n c#262₃\n c#262₄\n c#262₅\n c#262₆\n\n\n\n\n\n","category":"function"},{"location":"model_kit/#HomotopyContinuation2.ModelKit.evaluate","page":"ModelKit","title":"HomotopyContinuation2.ModelKit.evaluate","text":"evaluate(expr::Expression, subs...)\nevaluate(expr::AbstractArray{Expression}, subs...)\n\nEvaluate the given expression.\n\nExample\n\njulia> @var x y;\n\njulia> evaluate(x^2, x => 2)\n4\n\njulia> evaluate(x * y, [x,y] => [2, 3])\n6\n\njulia> evaluate([x^2, x * y], [x,y] => [2, 3])\n2-element Array{Int64,1}:\n 4\n 6\n\n# You can also use the callable syntax\njulia> [x^2, x * y]([x,y] => [2, 3])\n2-element Array{Int64,1}:\n 4\n 6\n\n\n\n\n\n","category":"function"},{"location":"model_kit/#HomotopyContinuation2.ModelKit.expand","page":"ModelKit","title":"HomotopyContinuation2.ModelKit.expand","text":"expand(e::Expression)\n\nExpand a given expression.\n\njulia> @var x y\n(x, y)\n\njulia> expand((x + y) ^ 2)\n2*x*y + x^2 + y^2\n\n\n\n\n\n","category":"function"},{"location":"model_kit/#HomotopyContinuation2.ModelKit.exponents_coefficients","page":"ModelKit","title":"HomotopyContinuation2.ModelKit.exponents_coefficients","text":"exponents_coefficients(f::Expression, vars::AbstractVector{Variable}; expanded = false)\n\nReturn a matrix M containing the exponents for all occuring terms (one term per column) and a vector c containing the corresponding coefficients. Expands the given expression f unless expanded = true.\n\n\n\n\n\n","category":"function"},{"location":"model_kit/#HomotopyContinuation2.ModelKit.horner","page":"ModelKit","title":"HomotopyContinuation2.ModelKit.horner","text":"horner(f::Expression, vars = variables(f))\n\nRewrite f using a multi-variate horner schema.\n\nExample\n\njulia> @var u v c[1:3]\n(u, v, Variable[c₁, c₂, c₃])\n\njulia> f = c[1] + c[2] * v + c[3] * u^2 * v^2 + c[3]u^3 * v\nc₁ + v*c₂ + u^2*v^2*c₃ + u^3*v*c₃\n\njulia> horner(f)\nc₁ + v*(c₂ + u^3*c₃ + u^2*v*c₃)\n\n\n\n\n\n","category":"function"},{"location":"model_kit/#HomotopyContinuation2.ModelKit.nvariables-Tuple{Expression}","page":"ModelKit","title":"HomotopyContinuation2.ModelKit.nvariables","text":"nvariables(expr::Expression; parameters = Variable[])\nnvariables(exprs::AbstractVector{Expression}; parameters = Variable[])\n\nObtain the number of variables used in the given expression not counting the the ones declared in parameters.\n\n\n\n\n\n","category":"method"},{"location":"model_kit/#HomotopyContinuation2.ModelKit.monomials","page":"ModelKit","title":"HomotopyContinuation2.ModelKit.monomials","text":"monomials(variables::AbstractVector{Variable}, d::Integer; homogeneous::Bool = false)\n\nCreate all monomials of a given degree in the given variables.\n\njulia> @var x y\n(x, y)\n\njulia> monomials([x,y], 2)\n6-element Array{Expression,1}:\nx^2\nx*y\ny^2\n  x\n  y\n  1\n\njulia> monomials([x,y], 2; homogeneous = true)\n3-element Array{Operation,1}:\n x ^ 2\n x * y\n y ^ 2\n\n\n\n\n\n","category":"function"},{"location":"model_kit/#HomotopyContinuation2.ModelKit.subs","page":"ModelKit","title":"HomotopyContinuation2.ModelKit.subs","text":"subs(expr::Expression, subsitutions::Pair...)\nsubs(exprs::AbstractVector{<:Expression}, subsitutions::Pair...)\n\nApply the given substitutions to the given expressions.\n\nExamples\n\n@var x y\n\njulia> subs(x^2, x => y)\ny ^ 2\n\njulia> subs(x * y, [x,y] => [x+2,y+2])\n(x + 2) * (y + 2)\n\njulia> subs([x + y, x^2], x => y + 2, y => x + 2)\n2-element Array{Expression,1}:\n 4 + x + y\n (2 + y)^2\n\n# You can also use the callable syntax\njulia> (x * y)([x,y] => [x+2,y+2])\n (x + 2) * (y + 2)\n\n\n\n\n\n","category":"function"},{"location":"model_kit/#HomotopyContinuation2.ModelKit.rand_poly","page":"ModelKit","title":"HomotopyContinuation2.ModelKit.rand_poly","text":"rand_poly(T = ComplexF64, vars::AbstractVector{Variable}, d::Integer; homogeneous::Bool = false)\n\nCreate a random dense polynomial of degree d in the given variables variables. Each coefficient is sampled independently via randn(T).\n\njulia> @var x y;\n\njulia> rand_poly(Float64, [x, y], 2)\n0.788764085756728 - 0.534507647623108*x - 0.778441366874946*y -\n 0.128891763280247*x*y + 0.878962738754971*x^2 + 0.550480741774464*y^2\n\n\n\n\n\n","category":"function"},{"location":"model_kit/#HomotopyContinuation2.ModelKit.to_dict","page":"ModelKit","title":"HomotopyContinuation2.ModelKit.to_dict","text":"to_dict(expr::Expression, vars::AbstractVector{Variable})\n\nReturn the coefficients of expr w.r.t. the given variables vars. Assumes that expr is expanded.\n\n\n\n\n\n","category":"function"},{"location":"model_kit/#HomotopyContinuation2.ModelKit.to_number","page":"ModelKit","title":"HomotopyContinuation2.ModelKit.to_number","text":"to_number(x::Expression)\n\nTries to unpack the Expression x to a native number type.\n\n```julia-repl julia> x = to_number(Expression(2)) 2\n\njulia> typeof(x) Int64\n\n\n\n\n\n","category":"function"},{"location":"model_kit/#HomotopyContinuation2.ModelKit.variables-Tuple{Expression}","page":"ModelKit","title":"HomotopyContinuation2.ModelKit.variables","text":"variables(expr::Expression; parameters = Variable[])\nvariables(exprs::AbstractVector{Expression}; parameters = Variable[])\n\nObtain all variables used in the given expression up to the ones declared in parameters.\n\nExample\n\njulia> @var x y a;\njulia> variables(x^2 + y)\n2-element Array{Variable,1}:\n x\n y\n\njulia> variables([x^2 + a, y]; parameters = [a])\n2-element Array{Variable,1}:\n x\n y\n\n\n\n\n\n","category":"method"},{"location":"model_kit/#System-1","page":"ModelKit","title":"System","text":"","category":"section"},{"location":"model_kit/#","page":"ModelKit","title":"ModelKit","text":"System\ndegrees(F::System)\nexpressions(F::System)\nmulti_degrees(::System)\nnparameters(::System)\nnvariables(::System)\nparameters(::System)\nsupport_coefficients(::System)\nvariables(::System)\nvariable_groups(::System)","category":"page"},{"location":"model_kit/#HomotopyContinuation2.ModelKit.System","page":"ModelKit","title":"HomotopyContinuation2.ModelKit.System","text":"System(exprs::AbstractVector{Expression};\n            variables = variables(exprssion),\n            parameters = Variable[])\nSystem(exprs, variables; parameters = Variable[])\n\nCreate a system from the given Expressions exprs. The variables determine also the variable ordering. The parameters argument allows to declare certain Variables as parameters.\n\nExamples\n\njulia> @var x y;\njulia> F = System([x^2, y^2]; variables = [y, x])\nSystem of length 2\n 2 variables: y, x\n\n x^2\n y^2\n\n# Systems are callable.\n# This evaluates F at y=2 and x=3\njulia> F([2, 3])\n2-element Array{Int64,1}:\n 9\n 4\n\nIt is also possible to declare parameters.\n\njulia> @var x y a b;\njulia> F = System([x^2 + a, y^2 + b]; variables = [y, x], parameters = [a, b])\nSystem of length 2\n 2 variables: y, x\n 2 parameters: a, b\n\n a + x^2\n b + y^2\n\njulia> F([2, 3], [5, -2])\n 2-element Array{Int64,1}:\n  14\n   2\n\n\n\n\n\n","category":"type"},{"location":"model_kit/#HomotopyContinuation2.ModelKit.degrees-Tuple{System}","page":"ModelKit","title":"HomotopyContinuation2.ModelKit.degrees","text":"degrees(F::System)\n\nReturn the degrees of the given system.\n\n\n\n\n\n","category":"method"},{"location":"model_kit/#HomotopyContinuation2.ModelKit.expressions-Tuple{System}","page":"ModelKit","title":"HomotopyContinuation2.ModelKit.expressions","text":"expressions(F::System)\n\nReturns the expressions of the given system F.\n\n\n\n\n\n","category":"method"},{"location":"model_kit/#HomotopyContinuation2.ModelKit.multi_degrees-Tuple{System}","page":"ModelKit","title":"HomotopyContinuation2.ModelKit.multi_degrees","text":"multi_degrees(F::System)\n\nReturn the degrees with respect to the given variable groups.\n\n\n\n\n\n","category":"method"},{"location":"model_kit/#HomotopyContinuation2.ModelKit.nparameters-Tuple{System}","page":"ModelKit","title":"HomotopyContinuation2.ModelKit.nparameters","text":"nparameters(F::System)\n\nReturns the number of parameters of the given system F.\n\n\n\n\n\n","category":"method"},{"location":"model_kit/#HomotopyContinuation2.ModelKit.nvariables-Tuple{System}","page":"ModelKit","title":"HomotopyContinuation2.ModelKit.nvariables","text":"nvariables(F::System)\n\nReturns the number of variables of the given system F.\n\n\n\n\n\n","category":"method"},{"location":"model_kit/#HomotopyContinuation2.ModelKit.parameters-Tuple{System}","page":"ModelKit","title":"HomotopyContinuation2.ModelKit.parameters","text":"parameters(F::System)\n\nReturns the parameters of the given system F.\n\n\n\n\n\n","category":"method"},{"location":"model_kit/#HomotopyContinuation2.ModelKit.support_coefficients-Tuple{System}","page":"ModelKit","title":"HomotopyContinuation2.ModelKit.support_coefficients","text":"support_coefficients(F::System)\n\nReturn the support of the system and the corresponding coefficients.\n\n\n\n\n\n","category":"method"},{"location":"model_kit/#HomotopyContinuation2.ModelKit.variables-Tuple{System}","page":"ModelKit","title":"HomotopyContinuation2.ModelKit.variables","text":"variables(F::System)\n\nReturns the variables of the given system F.\n\n\n\n\n\n","category":"method"},{"location":"model_kit/#HomotopyContinuation2.ModelKit.variable_groups-Tuple{System}","page":"ModelKit","title":"HomotopyContinuation2.ModelKit.variable_groups","text":"variable_groups(F::System)\n\nReturns the variable groups of the given system F.\n\n\n\n\n\n","category":"method"},{"location":"model_kit/#Homotopy-1","page":"ModelKit","title":"Homotopy","text":"","category":"section"},{"location":"model_kit/#","page":"ModelKit","title":"ModelKit","text":"Homotopy\nexpressions(::Homotopy)\nnparameters(::Homotopy)\nnvariables(::Homotopy)\nparameters(::Homotopy)\nvariables(::Homotopy)","category":"page"},{"location":"model_kit/#HomotopyContinuation2.ModelKit.Homotopy","page":"ModelKit","title":"HomotopyContinuation2.ModelKit.Homotopy","text":"Homotopy(exprs, vars, t, parameters = Variable[])\n\nCreate a homotopy H(vars,t) from the given Expressions exprs where vars are the given variables and t is the dedicated variable parameterizing the family of systems. The parameters argument allows to declare certain Variables as parameters.\n\nExample\n\njulia> @var x y t;\n\njulia> H = Homotopy([x + t, y + 2t], [y, x], t)\nHomotopy in t of length 2\n 2 variables: y, x\n\n t + x\n 2*t + y\n\njulia> H([2, 3], 0)\n2-element Array{Int64,1}:\n 3\n 2\n\n\njulia> H([2, 3], 1)\n2-element Array{Int64,1}:\n 4\n 4\n\nIt is also possible to declare additional variables.\n\njulia> @var x y t a b;\njulia> H = Homotopy([x^2 + t*a, y^2 + t*b], [x, y], t, [a, b])\nHomotopy in t of length 2\n 2 variables: x, y\n 2 parameters: a, b\n\n a*t + x^2\n b*t + y^2\njulia> H([2, 3], 1, [5, 2])\n2-element Array{Int64,1}:\n 9\n 11\n\n\n\n\n\n","category":"type"},{"location":"model_kit/#HomotopyContinuation2.ModelKit.expressions-Tuple{Homotopy}","page":"ModelKit","title":"HomotopyContinuation2.ModelKit.expressions","text":"expressions(H::Homotopy)\n\nReturns the expressions of the given homotopy H.\n\n\n\n\n\n","category":"method"},{"location":"model_kit/#HomotopyContinuation2.ModelKit.nparameters-Tuple{Homotopy}","page":"ModelKit","title":"HomotopyContinuation2.ModelKit.nparameters","text":"nparameters(H::Homotopy)\n\nReturns the number of parameters of the given homotopy H.\n\n\n\n\n\n","category":"method"},{"location":"model_kit/#HomotopyContinuation2.ModelKit.nvariables-Tuple{Homotopy}","page":"ModelKit","title":"HomotopyContinuation2.ModelKit.nvariables","text":"nvariables(H::Homotopy)\n\nReturns the number of variables of the given homotopy H.\n\n\n\n\n\n","category":"method"},{"location":"model_kit/#HomotopyContinuation2.ModelKit.parameters-Tuple{Homotopy}","page":"ModelKit","title":"HomotopyContinuation2.ModelKit.parameters","text":"parameters(H::Homotopy)\n\nReturns the parameters of the given homotopy H.\n\n\n\n\n\n","category":"method"},{"location":"model_kit/#HomotopyContinuation2.ModelKit.variables-Tuple{Homotopy}","page":"ModelKit","title":"HomotopyContinuation2.ModelKit.variables","text":"variables(H::Homotopy)\n\nReturns the variables of the given homotopy H.\n\n\n\n\n\n","category":"method"},{"location":"solve/#Solve-1","page":"Solve","title":"Solve","text":"","category":"section"},{"location":"solve/#","page":"Solve","title":"Solve","text":"solve","category":"page"},{"location":"solve/#HomotopyContinuation2.solve","page":"Solve","title":"HomotopyContinuation2.solve","text":"solve(...)\n\nTODO\n\n\n\n\n\n","category":"function"},{"location":"systems_homotopies/#Systems-and-Homotopies-1","page":"Systems and Homotopies","title":"Systems and Homotopies","text":"","category":"section"},{"location":"systems_homotopies/#","page":"Systems and Homotopies","title":"Systems and Homotopies","text":"Systems (AbstractSystem) and homotopies (AbstractHomotopy) are used for the numerical computations.","category":"page"},{"location":"systems_homotopies/#Systems-1","page":"Systems and Homotopies","title":"Systems","text":"","category":"section"},{"location":"systems_homotopies/#","page":"Systems and Homotopies","title":"Systems and Homotopies","text":"Systems (AbstractSystem) are the basic building blocks of homotopies.","category":"page"},{"location":"systems_homotopies/#","page":"Systems and Homotopies","title":"Systems and Homotopies","text":"AbstractSystem","category":"page"},{"location":"systems_homotopies/#HomotopyContinuation2.AbstractSystem","page":"Systems and Homotopies","title":"HomotopyContinuation2.AbstractSystem","text":"AbstractSystem\n\nAn abstract type representing a polynomial system F(x).\n\nThe following systems are available:\n\nAffineChartSystem\nCompositionSystem\nFixedParameterSystem\nModelKitSystem\nRandomizedSystem\n\n\n\n\n\n","category":"type"},{"location":"systems_homotopies/#AffineChartSystem-1","page":"Systems and Homotopies","title":"AffineChartSystem","text":"","category":"section"},{"location":"systems_homotopies/#","page":"Systems and Homotopies","title":"Systems and Homotopies","text":"AffineChartSystem\non_affine_chart(F::System, dims)","category":"page"},{"location":"systems_homotopies/#HomotopyContinuation2.AffineChartSystem","page":"Systems and Homotopies","title":"HomotopyContinuation2.AffineChartSystem","text":"AffineChartSystem(F::AbstractSystem, v::PVector{T,N})\n\nGiven a system F(x) (ℙ^m_1    ℙ^m_N)  ℂⁿ this creates a new affine system F which operates on the affine chart defined by the vector v  ℙ^m_1    ℙ^m_N and the augmented conditions vᵀx = 1.\n\n\n\n\n\n","category":"type"},{"location":"systems_homotopies/#HomotopyContinuation2.on_affine_chart-Tuple{System,Any}","page":"Systems and Homotopies","title":"HomotopyContinuation2.on_affine_chart","text":"on_affine_chart(F::Union{System,AbstractSystem}, dimensions)\n\nConstruct an AffineChartSystem on a randomly generated chart v. Each entry is drawn idepdently from a univariate normal distribution.\n\n\n\n\n\n","category":"method"},{"location":"systems_homotopies/#CompositionSystem-1","page":"Systems and Homotopies","title":"CompositionSystem","text":"","category":"section"},{"location":"systems_homotopies/#","page":"Systems and Homotopies","title":"Systems and Homotopies","text":"CompositionSystem\ncompose","category":"page"},{"location":"systems_homotopies/#HomotopyContinuation2.CompositionSystem","page":"Systems and Homotopies","title":"HomotopyContinuation2.CompositionSystem","text":"CompositionSystem(G::AbstractSystem, F::AbstractSystem)\n\nConstruct the system G(F(xp)p). Note that the parameters are passed to G and F are identical.\n\n\n\n\n\n","category":"type"},{"location":"systems_homotopies/#HomotopyContinuation2.compose","page":"Systems and Homotopies","title":"HomotopyContinuation2.compose","text":"compose(G::Union{AbstractSystem,System}, F::Union{AbstractSystem,System})\n\nConstruct the composition G(F(x)). You can also use the infix operator ∘ (written by \\circ).\n\nExample\n\njulia> @var a b c x y z\n\njulia> g = System([a * b * c]);\n\njulia> f = System([x+y, y + z, x + z]);\n\njulia> compose(g, f)\nComposition G ∘ F:\nF:\nModelKitSystem{(0xbb16b481c0808501, 1)}:\nCompiled: System of length 3\n 3 variables: x, y, z\n\n x + y\n y + z\n x + z\n\nG:\nModelKitSystem{(0xf0a2384a42428501, 1)}:\nCompiled: System of length 1\n 3 variables: a, b, c\n\n a*b*c\n\n\njulia> (g ∘ f)([x,y,z])\n1-element Array{Expression,1}:\n (x + z)*(y + z)*(x + y)\n\n\n\n\n\n","category":"function"},{"location":"systems_homotopies/#FixedParameterSystem-1","page":"Systems and Homotopies","title":"FixedParameterSystem","text":"","category":"section"},{"location":"systems_homotopies/#","page":"Systems and Homotopies","title":"Systems and Homotopies","text":"FixedParameterSystem\nfix_parameters","category":"page"},{"location":"systems_homotopies/#HomotopyContinuation2.FixedParameterSystem","page":"Systems and Homotopies","title":"HomotopyContinuation2.FixedParameterSystem","text":"FixedParameterSystem(F:AbstractSystem, parameters)\n\nConstruct a system from the given AbstractSystem F with the given parameters fixed.\n\n\n\n\n\n","category":"type"},{"location":"systems_homotopies/#HomotopyContinuation2.fix_parameters","page":"Systems and Homotopies","title":"HomotopyContinuation2.fix_parameters","text":"fix_parameters(F::AbstractSystem, p)\n\nFix the parameters of the given system F. Returns a FixedParameterSystem.\n\n\n\n\n\n","category":"function"},{"location":"systems_homotopies/#ModelKitSystem-1","page":"Systems and Homotopies","title":"ModelKitSystem","text":"","category":"section"},{"location":"systems_homotopies/#","page":"Systems and Homotopies","title":"Systems and Homotopies","text":"ModelKitSystem","category":"page"},{"location":"systems_homotopies/#HomotopyContinuation2.ModelKitSystem","page":"Systems and Homotopies","title":"HomotopyContinuation2.ModelKitSystem","text":"ModelKitSystem(F:System)\n\nConstruct a system from the given System F. The difference to F is that this compiles a straight line programm for the fast evaluation of F and that ModelKitSystem <: AbstractSystem.\n\n\n\n\n\n","category":"type"},{"location":"systems_homotopies/#RandomizedSystem-1","page":"Systems and Homotopies","title":"RandomizedSystem","text":"","category":"section"},{"location":"systems_homotopies/#","page":"Systems and Homotopies","title":"Systems and Homotopies","text":"RandomizedSystem","category":"page"},{"location":"systems_homotopies/#HomotopyContinuation2.RandomizedSystem","page":"Systems and Homotopies","title":"HomotopyContinuation2.RandomizedSystem","text":"RandomizedSystem(F::Union{System,AbstractSystem}, k::Integer) <: AbstractSystem\n\nGiven a n  N system F with n  N this constructs the system mathfrakR(F k)(x) = I AF(x) where I is a k  k identity matrix and A is random complex k  n matrix. See Chapter 13.5 in [SW05] for more details.\n\nRandomizedSystem(F::Union{System,AbstractSystem}, A::Matrix{ComplexF64})\n\nExplicitly provide the used randomization matrix A.\n\n[SW05]: Sommese, A. J., & Wampler, C. W. (2005). The Numerical Solution of Systems of Polynomials Arising in Engineering and Science. World Scientific.\n\n\n\n\n\n","category":"type"},{"location":"systems_homotopies/#Homotopies-1","page":"Systems and Homotopies","title":"Homotopies","text":"","category":"section"},{"location":"systems_homotopies/#","page":"Systems and Homotopies","title":"Systems and Homotopies","text":"Homotopies (AbstractHomotopy) are at the heart of homotopy continuation. A homotopy is a parameterized family H(xt) of polynomial systems. By convention, homotopies are tracked from t=1 to t=0, i.e., H(x1) is considered the start system and H(x0) is the target system.","category":"page"},{"location":"systems_homotopies/#","page":"Systems and Homotopies","title":"Systems and Homotopies","text":"AbstractHomotopy","category":"page"},{"location":"systems_homotopies/#HomotopyContinuation2.AbstractHomotopy","page":"Systems and Homotopies","title":"HomotopyContinuation2.AbstractHomotopy","text":"AbstractHomotopy\n\nAn abstract type representing a homotopy H(xt).\n\nThe following homotopies are available:\n\nAffineChartHomotopy\nAffineSubspaceHomotopy\nModelKitHomotopy\nParameterHomotopy\nStraightLineHomotopy\n\n\n\n\n\n","category":"type"},{"location":"systems_homotopies/#AffineChartHomotopy-1","page":"Systems and Homotopies","title":"AffineChartHomotopy","text":"","category":"section"},{"location":"systems_homotopies/#","page":"Systems and Homotopies","title":"Systems and Homotopies","text":"AffineChartHomotopy\non_affine_chart(F::Homotopy, dims)","category":"page"},{"location":"systems_homotopies/#HomotopyContinuation2.AffineChartHomotopy","page":"Systems and Homotopies","title":"HomotopyContinuation2.AffineChartHomotopy","text":"AffineChartHomotopy(H::AbstractHomotopy, v::PVector{T,N})\n\nGiven a homotopy H(xt) (ℙ^m_1    ℙ^m_N)  ℂ  ℂⁿ this creates a new affine homotopy H which operates on the affine chart defined by the vector v  ℙ^m_1    ℙ^m_N and the augmented conditions vᵀx = 1.\n\n\n\n\n\n","category":"type"},{"location":"systems_homotopies/#HomotopyContinuation2.on_affine_chart-Tuple{Homotopy,Any}","page":"Systems and Homotopies","title":"HomotopyContinuation2.on_affine_chart","text":"on_affine_chart(H::Union{Homotopy,AbstractHomotopy}, proj_dims)\n\nConstruct an AffineChartHomotopy on a randomly generated chart v. Each entry is drawn idepdently from a univariate normal distribution.\n\n\n\n\n\n","category":"method"},{"location":"systems_homotopies/#AffineSubspaceHomotopy-1","page":"Systems and Homotopies","title":"AffineSubspaceHomotopy","text":"","category":"section"},{"location":"systems_homotopies/#","page":"Systems and Homotopies","title":"Systems and Homotopies","text":"AffineSubspaceHomotopy\nset_subspaces!","category":"page"},{"location":"systems_homotopies/#HomotopyContinuation2.AffineSubspaceHomotopy","page":"Systems and Homotopies","title":"HomotopyContinuation2.AffineSubspaceHomotopy","text":"AffineSubspaceHomotopy(F::System, V::AffineSubspace, W::AffineSubspace)\nAffineSubspaceHomotopy(F::AbstractSystem, V::AffineSubspace, W::AffineSubspace)\n\nCreates a homotopy H(xt) = (F  γ(t))(x) where γ(t) is a family of affine subspaces such that H(x1) = (F  V)(x) and H(x0) = (F  W)(x). Here γ(t) is the geodesic between V and W in the affine Grassmanian, i.e., it is the curve of minimal length connecting V and W. See also AffineSubspace and geodesic and the references therein.\n\n\n\n\n\n","category":"type"},{"location":"systems_homotopies/#HomotopyContinuation2.set_subspaces!","page":"Systems and Homotopies","title":"HomotopyContinuation2.set_subspaces!","text":"set_subspaces!(H::AffineSubspaceHomotopy, start::AffineSubspace, target::AffineSubspace)\n\nUpdate the homotopy H to track from the affine subspace start to target.\n\n\n\n\n\n","category":"function"},{"location":"systems_homotopies/#ModelKitHomotopy-1","page":"Systems and Homotopies","title":"ModelKitHomotopy","text":"","category":"section"},{"location":"systems_homotopies/#","page":"Systems and Homotopies","title":"Systems and Homotopies","text":"ModelKitHomotopy","category":"page"},{"location":"systems_homotopies/#HomotopyContinuation2.ModelKitHomotopy","page":"Systems and Homotopies","title":"HomotopyContinuation2.ModelKitHomotopy","text":"ModelKitHomotopy(H::Homotopy, parameters = nothing)\n\nConstruct a homotopy from the given homotopy H with the given parameters fixed. The difference to H is that this compiles a straight line programm for the fast evaluation of H and that ModelKitHomotopy <: AbstractHomotopy.\n\n\n\n\n\n","category":"type"},{"location":"systems_homotopies/#ParameterHomotopy-1","page":"Systems and Homotopies","title":"ParameterHomotopy","text":"","category":"section"},{"location":"systems_homotopies/#","page":"Systems and Homotopies","title":"Systems and Homotopies","text":"ParameterHomotopy","category":"page"},{"location":"systems_homotopies/#HomotopyContinuation2.ParameterHomotopy","page":"Systems and Homotopies","title":"HomotopyContinuation2.ParameterHomotopy","text":"ParameterHomotopy(F::Union{AbstractSystem,System}; start_parameters, target_parameters)\nParameterHomotopy(F::Union{AbstractSystem,System}, start_parameters, target_parameters)\n\nConstruct the parameter homotopy H(xt) = F(x t p + (1 - t) q) where p is start_parameters and q is target_parameters.\n\n\n\n\n\n","category":"type"},{"location":"systems_homotopies/#StraightLineHomotopy-1","page":"Systems and Homotopies","title":"StraightLineHomotopy","text":"","category":"section"},{"location":"systems_homotopies/#","page":"Systems and Homotopies","title":"Systems and Homotopies","text":"StraightLineHomotopy","category":"page"},{"location":"systems_homotopies/#HomotopyContinuation2.StraightLineHomotopy","page":"Systems and Homotopies","title":"HomotopyContinuation2.StraightLineHomotopy","text":"StraightLineHomotopy(G::System, F::System; gamma = 1.0)\nStraightLineHomotopy(G::AbstractSystem, F::AbstractSystem; gamma = 1.0)\n\nConstructs the straight line homotopy H(x t) = γ t G(x) + (1-t) F(x) where γ is gamma.\n\n\n\n\n\n","category":"type"},{"location":"misc/#Miscellaneous-1","page":"Miscellaneous","title":"Miscellaneous","text":"","category":"section"},{"location":"misc/#Newton's-method-1","page":"Miscellaneous","title":"Newton's method","text":"","category":"section"},{"location":"misc/#","page":"Miscellaneous","title":"Miscellaneous","text":"newton\nNewtonResult\nis_success(::NewtonResult)\nNewtonCache","category":"page"},{"location":"misc/#HomotopyContinuation2.newton","page":"Miscellaneous","title":"HomotopyContinuation2.newton","text":"newton(\n    F::AbstractSystem,\n    x₀::AbstractVector,\n    norm::AbstractNorm = InfNorm(),\n    cache::NewtonCache = NewtonCache(F, x₀);\n    options...\n)\n\nAn implemenetation of a local Newton's method with various options to specify convergence criteria. Returns a NewtonResult. The computations are always performed in complex arithmetic with double precision, i.e., using Complex{Float64}. The optional cache argument pre-allocates the necessary memory. This is useful if the method is called repeatedly.\n\nOptions\n\nabs_tol::Float64 = 1e-8: The method is declared converged if norm(xᵢ₊₁ - xᵢ) < abs_tol.\nrel_tol::Float64 = abs_tol: The method is declared converged if norm(xᵢ₊₁ - xᵢ) < abs_tol * norm(x₀).\nmax_iters::Int = 20: The maximal number of iterations.\nextended_precision::Bool = false: An optional use of extended precision for the evaluation of F(x). This can increase the achievable accuracy.\ncontraction_factor::Float64 = 1.0: The Newton updates have to satisfy xᵢ₁ - xᵢ  a^2^(i-1)x₁ - x₀ for i  1 where a is contraction_factor.\nmin_contraction_iters::Int = typemax(Int):  The minimal number of iterations the contraction_factor has to be satisfied. If after min_contraction_iters many iterations the contraction factor is not satisfied the step is accepted anyway.\nmax_abs_norm_first_update::Float64 = Inf: The initial guess x₀ is rejected if norm(x₁ - x₀) >  max_abs_norm_first_update\nmax_rel_norm_first_update::Float64 = max_abs_norm_first_update: The initial guess x₀ is rejected if norm(x₁ - x₀) >  max_rel_norm_first_update * norm(x₀)\n\n\n\n\n\n","category":"function"},{"location":"misc/#HomotopyContinuation2.NewtonResult","page":"Miscellaneous","title":"HomotopyContinuation2.NewtonResult","text":"NewtonResult\n\nResult returned by newton.\n\nFields\n\nreturn_code::Symbol: Can be :success, :rejected or :max_iters.\nx::Vector{ComplexF64}: The last value obtained.\naccuracy::Float64: Estimate of the distance of x to a true zero.\niters::Int Number of iterations performed.\ncontraction_ratio::Float64: The value |xᵢ - xᵢ₋₁| / |xᵢ₋₁ - xᵢ₋₂|.\n\n\n\n\n\n","category":"type"},{"location":"misc/#HomotopyContinuation2.is_success-Tuple{NewtonResult}","page":"Miscellaneous","title":"HomotopyContinuation2.is_success","text":"is_success(R::NewtonResult)\n\nReturns true if the newton was successfull.\n\n\n\n\n\n","category":"method"},{"location":"misc/#HomotopyContinuation2.NewtonCache","page":"Miscellaneous","title":"HomotopyContinuation2.NewtonCache","text":"NewtonCache(F::AbstractSystem)\n\nPre-allocates the necessary memory for newton.\n\n\n\n\n\n","category":"type"},{"location":"misc/#Norms-1","page":"Miscellaneous","title":"Norms","text":"","category":"section"},{"location":"misc/#","page":"Miscellaneous","title":"Miscellaneous","text":"AbstractNorm\nInfNorm\nWeightedNorm\ndistance(u, v, ::AbstractNorm)\nnorm(u, ::AbstractNorm)\ninit!(::WeightedNorm, ::AbstractVector)\nupdate!(::WeightedNorm, ::AbstractVector)","category":"page"},{"location":"misc/#HomotopyContinuation2.AbstractNorm","page":"Miscellaneous","title":"HomotopyContinuation2.AbstractNorm","text":"AbstractNorm\n\nAn AbstractNorm represents any norm of a vector space. All norms are callable. norm(x) computes the norm of x and norm(x,y) computes the distance norm(x - y).\n\n\n\n\n\n","category":"type"},{"location":"misc/#HomotopyContinuation2.InfNorm","page":"Miscellaneous","title":"HomotopyContinuation2.InfNorm","text":"InfNorm <: AbstractNorm\n\nThe infinity or maximum norm.\n\n\n\n\n\n","category":"type"},{"location":"misc/#HomotopyContinuation2.WeightedNorm","page":"Miscellaneous","title":"HomotopyContinuation2.WeightedNorm","text":"WeightedNorm(d::AbstractVector, norm::AbstractNorm; options...)\nWeightedNorm(norm::AbstractNorm, n::Integer; options...)\nWeightedNorm(norm::AbstractNorm, x::AbstractVector; options...)\n\nA WeightedNorm represents a weighted variant of norm norm of a n-dimensional vector space.A norm||x||is weighted by introducing a vector of additional weightsdsuch that the new norm is||D⁻¹x||whereDis the diagonal matrix with diagonald. The WeightedNorm is desigened to change the weights dynamically by using init!(::WeightedNorm, x) and update!(::WeightedNorm, x). The weights are there constructed such that D¹x  10. The weights can be accessed and changed by indexing.\n\nOptions\n\nscale_min = sqrt(eps()): The minimal size of dᵢ is scale_min time the (weighted) norm of x.\nscale_abs_min = min(scale_min^2, 200 * sqrt(eps())): The absolute minimal size of dᵢ.\nscale_max = 1.0 / eps() / sqrt(2): The absolute maximal size of dᵢ\n\n\n\n\n\n","category":"type"},{"location":"misc/#HomotopyContinuation2.distance-Tuple{Any,Any,AbstractNorm}","page":"Miscellaneous","title":"HomotopyContinuation2.distance","text":"distance(u, v, norm::AbstractNorm)\n\nCompute the distance ||u-v|| with respect to the given norm norm.\n\n\n\n\n\n","category":"method"},{"location":"misc/#LinearAlgebra.norm-Tuple{Any,AbstractNorm}","page":"Miscellaneous","title":"LinearAlgebra.norm","text":"norm(u, norm::AbstractNorm)\n\nCompute the norm ||u|| with respect to the given norm norm.\n\n\n\n\n\n","category":"method"},{"location":"misc/#HomotopyContinuation2.init!-Tuple{WeightedNorm,AbstractArray{T,1} where T}","page":"Miscellaneous","title":"HomotopyContinuation2.init!","text":"init!(w::WeightedNorm, x::AbstractVector)\n\nSetup the weighted norm w for x.\n\n\n\n\n\n","category":"method"},{"location":"misc/#HomotopyContinuation2.update!-Tuple{WeightedNorm,AbstractArray{T,1} where T}","page":"Miscellaneous","title":"HomotopyContinuation2.update!","text":"update!(w::WeightedNorm, x::AbstractVector)\n\nUpdate the weighted norm w for x, this will interpolate between the previous weights and the norm of x.\n\n\n\n\n\n","category":"method"},{"location":"misc/#Debugging-1","page":"Miscellaneous","title":"Debugging","text":"","category":"section"},{"location":"misc/#","page":"Miscellaneous","title":"Miscellaneous","text":"path_info","category":"page"},{"location":"misc/#HomotopyContinuation2.path_info","page":"Miscellaneous","title":"HomotopyContinuation2.path_info","text":"path_info(tracker::Tracker, x₀, t₁ = 1.0, t₀ = 0.0; debug::Bool = false, kwargs...)\n\nTrack a path using the given tracker and start value x₀. This returns a struct containing detailed information about the tracked path.\n\n\n\n\n\n","category":"function"},{"location":"tracker/#Tracker-1","page":"Tracker","title":"Tracker","text":"","category":"section"},{"location":"tracker/#","page":"Tracker","title":"Tracker","text":"Tracker is a data structure to track for a given AbstractHomotopy H(xt) a solution x from t₁  ℂ to t₀  ℂ, i.e.,  H(xt₁) = 0 and x with H(xt₀) = 0 is returned. This is done by following an implicitly defined smooth path x(t) using a predictor-corrector scheme. In particular, it is assumed that for all t on the line segment between t₁ and t₀ the Jacobian H_x(x(t)t) has full column-rank. The algorithm uses as an predictor a Padé approximant of order (2,1) and as a corrector Newton's method. The details of the algorithm are described in the article [Tim20].","category":"page"},{"location":"tracker/#Constructor-and-Options-1","page":"Tracker","title":"Constructor and Options","text":"","category":"section"},{"location":"tracker/#","page":"Tracker","title":"Tracker","text":"Tracker\nTrackerOptions\nTrackerParameters\nDEFAULT_TRACKER_PARAMETERS\nCONSERVATIVE_TRACKER_PARAMETERS\nFAST_TRACKER_PARAMETERS","category":"page"},{"location":"tracker/#HomotopyContinuation2.Tracker","page":"Tracker","title":"HomotopyContinuation2.Tracker","text":"Tracker(H::AbstractHomotopy;\n        options = TrackerOptions(),\n        weighted_norm_options = WeightedNormOptions())\n\nConstruct a tracker for the given homotopy H. The algorithm computes along the path x(t) the local derivatives up to order 4. For options see also TrackerOptions. The algorithm uses as a weighted infinity norm to measure distances. See also WeightedNorm.\n\n[Tim20]: Timme, S. \"Mixed Precision Path Tracking for Polynomial Homotopy Continuation\". arXiv:1902.02968 (2020)\n\nExample\n\nWe want to solve the system\n\n@var x y t\nF = System([x^2 + y^2 - 3, 2x^2 + 0.5x*y + 3y^2 - 2])\n\nusing a total degree homotopy and Tracker.\n\n# construct start system and homotopy\nG = System(im * [x^2 - 1, y^2 - 1])\nH = StraightLineHomotopy(G, F)\nstart_solutions = [[1,1], [-1,1], [1,-1], [-1,-1]]\n# construct tracker\ntracker = Tracker(H)\n# track each start solution separetely\nresults = track.(tracker, start_solutions)\nprintln(\"# successfull: \", count(is_success, results))\n\nWe see that we tracked all 4 paths successfully.\n\n# successfull: 4\n\n\n\n\n\n","category":"type"},{"location":"tracker/#HomotopyContinuation2.TrackerOptions","page":"Tracker","title":"HomotopyContinuation2.TrackerOptions","text":"TrackerOptions(; options...)\n\nThe set of options for a Tracker.\n\nOptions\n\nautomatic_differentiation::Int = 3: The value automatic_differentiation determines up to which order the derivative is computed using automatic differentiation. Otherwise numerical differentiation is used. The automatic differentiation results in additional compilation time, however for numerically challenging paths it is strongly recommended to use automatic_differentiation = 3.\nmax_steps::Int = 10_000: The maximal number of steps a tracker attempts\nmax_step_size::Float64 = Inf: The maximal size of a step\nmax_initial_step_size::Float64 = Inf: The maximal size of the first step\nmin_step_size::Float64 = 1e-48: The minimal step size. If a smaller step size would be necessary, then the tracking gets terminated.\nextended_precision::Bool = true: Whether to allow for the use of extended precision, if necessary, in some computations. This can greatly improve the ability to track numerically difficult paths.\nterminate_cond::Float64 = 1e13: If the relative component-wise condition number cond(H_x, ẋ) is larger than terminate_cond then the path is terminated as too ill-conditioned.\nparameters::Union{Symbol,TrackerParameters} = :default Set the TrackerParameters to control the performance of the path tracking algorithm. The values :default, :conservative and :fast are shorthands for using DEFAULT_TRACKER_PARAMETERS, CONSERVATIVE_TRACKER_PARAMETERS resp. FAST_TRACKER_PARAMETERS.\n\n\n\n\n\n","category":"type"},{"location":"tracker/#HomotopyContinuation2.TrackerParameters","page":"Tracker","title":"HomotopyContinuation2.TrackerParameters","text":"TrackerParameters\n\nParameters that control the performance and robustness characteristics of the path tracking algorithm. See [Tim20] for an explanation and derivation of the parameters. We provide three sets of parameters for common use cases:\n\nDEFAULT_TRACKER_PARAMETERS\nFAST_TRACKER_PARAMETERS\nCONSERVATIVE_TRACKER_PARAMETERS\n\n[Tim20]: Timme, S. \"Mixed Precision Path Tracking for Polynomial Homotopy Continuation\". arXiv:1902.02968 (2020)\n\n\n\n\n\n","category":"type"},{"location":"tracker/#HomotopyContinuation2.DEFAULT_TRACKER_PARAMETERS","page":"Tracker","title":"HomotopyContinuation2.DEFAULT_TRACKER_PARAMETERS","text":"The default TrackerParameters which have a good balance between robustness and efficiency.\n\n\n\n\n\n","category":"constant"},{"location":"tracker/#HomotopyContinuation2.CONSERVATIVE_TRACKER_PARAMETERS","page":"Tracker","title":"HomotopyContinuation2.CONSERVATIVE_TRACKER_PARAMETERS","text":"TrackerParameters which trade robustness against some speed.\n\n\n\n\n\n","category":"constant"},{"location":"tracker/#HomotopyContinuation2.FAST_TRACKER_PARAMETERS","page":"Tracker","title":"HomotopyContinuation2.FAST_TRACKER_PARAMETERS","text":"TrackerParameters which trade speed against a higher chance of path jumping.\n\n\n\n\n\n","category":"constant"},{"location":"tracker/#Tracking-1","page":"Tracker","title":"Tracking","text":"","category":"section"},{"location":"tracker/#","page":"Tracker","title":"Tracker","text":"track(tracker::Tracker, x₁::AbstractVector, t₁::Number, t₀::Number)","category":"page"},{"location":"tracker/#HomotopyContinuation2.track-Tuple{Tracker,AbstractArray{T,1} where T,Number,Number}","page":"Tracker","title":"HomotopyContinuation2.track","text":" track(tracker::Tracker, x::AbstractVector, t₁ = 1.0, t₀ = 0.0; debug::Bool = false)\n\nTrack the given solution x at t₁ using tracker to a solution at t₀.\n\ntrack(tracker::Tracker, r::TrackerResult, t₁ = 1.0, t₀ = 0.0; debug::Bool = false)\n\nTrack the solution of the result r from t₁ to t₀.\n\n\n\n\n\n","category":"method"},{"location":"tracker/#Result-1","page":"Tracker","title":"Result","text":"","category":"section"},{"location":"tracker/#","page":"Tracker","title":"Tracker","text":"TrackerResult\nsolution(::TrackerResult)\nis_success(::TrackerResult)\nis_invalid_startvalue(::TrackerResult)\nsteps(::TrackerResult)\naccepted_steps(::TrackerResult)\nrejected_steps(::TrackerResult)","category":"page"},{"location":"tracker/#HomotopyContinuation2.TrackerResult","page":"Tracker","title":"HomotopyContinuation2.TrackerResult","text":"TrackerResult\n\nContaining the result of tracking a path with a Tracker.\n\nFields\n\nreturn_code::Symbol: A code indicating whether the tracking was successfull (:success). See TrackerCode for all possible values.\nsolution::V: The solution when the tracking stopped.\nt::ComplexF64: The value of t when the tracking stopped.\naccuracy::Float64: Estimate of the relative accuracy of the solution.\naccepted_steps::Int: Number of steps that got accepted.\nrejected_steps::Int: Number of steps that got rejected.\nextended_precision::Bool: Indicate whether extended precision is necessary to achieve the accuracy of the solution.\nextended_precision_used::Bool: This is true if during the tracking at any point extended precision was used.\n\n\n\n\n\n","category":"type"},{"location":"tracker/#HomotopyContinuation2.solution-Tuple{TrackerResult}","page":"Tracker","title":"HomotopyContinuation2.solution","text":"solution(result::TrackerResult)\n\nReturns the solutions obtained by the Tracker.\n\n\n\n\n\n","category":"method"},{"location":"tracker/#HomotopyContinuation2.is_success-Tuple{TrackerResult}","page":"Tracker","title":"HomotopyContinuation2.is_success","text":"is_success(result::TrackerResult)\n\nReturns true if the path tracking was successfull.\n\n\n\n\n\n","category":"method"},{"location":"tracker/#HomotopyContinuation2.is_invalid_startvalue-Tuple{TrackerResult}","page":"Tracker","title":"HomotopyContinuation2.is_invalid_startvalue","text":"is_invalid_startvalue(result::TrackerResult)\n\nReturns true if the path tracking failed since the start value was invalid.\n\n\n\n\n\n","category":"method"},{"location":"tracker/#HomotopyContinuation2.steps-Tuple{TrackerResult}","page":"Tracker","title":"HomotopyContinuation2.steps","text":"steps(result::TrackerResult)\n\nReturns the number of steps done.\n\n\n\n\n\n","category":"method"},{"location":"tracker/#HomotopyContinuation2.accepted_steps-Tuple{TrackerResult}","page":"Tracker","title":"HomotopyContinuation2.accepted_steps","text":"accepted_steps(result::TrackerResult)\n\nReturns the number of accepted steps.\n\n\n\n\n\n","category":"method"},{"location":"tracker/#HomotopyContinuation2.rejected_steps-Tuple{TrackerResult}","page":"Tracker","title":"HomotopyContinuation2.rejected_steps","text":"rejected_steps(result::TrackerResult)\n\nReturns the number of rejected_steps steps.\n\n\n\n\n\n","category":"method"},{"location":"tracker/#Low-level-API-1","page":"Tracker","title":"Low-level API","text":"","category":"section"},{"location":"tracker/#","page":"Tracker","title":"Tracker","text":"track!(tracker::Tracker, x₁::AbstractVector, t₁::Number, t₀::Number)\ninit!(tracker::Tracker, ::TrackerResult, ::Number, ::Number)\nTrackerCode\nis_success(::TrackerCode.codes)\nis_tracking(::TrackerCode.codes)\nis_invalid_startvalue(::TrackerCode.codes)\nis_terminated(::TrackerCode.codes)\n","category":"page"},{"location":"tracker/#HomotopyContinuation2.track!-Tuple{Tracker,AbstractArray{T,1} where T,Number,Number}","page":"Tracker","title":"HomotopyContinuation2.track!","text":"track!(tracker::Tracker, x, t₁ = 1.0, t₀ = 0.0; debug::Bool = false)\n\nThe same as track but only returns the final TrackerCode.\n\ntrack!(tracker::Tracker, t₀; debug::Bool = false)\n\nTrack with tracker the current solution to t₀. This keeps the current state.\n\n\n\n\n\n","category":"method"},{"location":"tracker/#HomotopyContinuation2.init!-Tuple{Tracker,TrackerResult,Number,Number}","page":"Tracker","title":"HomotopyContinuation2.init!","text":"init!(tracker::Tracker, x₁, t₁, t₀)\n\nSetup tracker to track x₁ from t₁ to t₀.\n\ninit!(tracker::Tracker, t₀)\n\nSetup tracker to continue tracking the current solution to t₀. This keeps the current state.\n\n\n\n\n\n","category":"method"},{"location":"tracker/#HomotopyContinuation2.TrackerCode","page":"Tracker","title":"HomotopyContinuation2.TrackerCode","text":"TrackerCode\n\nThe possible states a CoreTracker can have are of type TrackerCode.codes and can be\n\nTrackerCode.success: Indicates a successfull tracking.\nTrackerCode.tracking: The tracking is still in progress.\nTrackerCode.terminated_accuracy_limit: Tracking terminaed since the accuracy was insufficient.\nTrackerCode.terminated_invalid_startvalue: Tracking terminated since the provided start value was invalid.\nTrackerCode.terminated_ill_conditioned: Tracking terminated since the path was too ill-conditioned.\nTrackerCode.terminated_max_steps: Tracking terminated since maximal number of steps is reached.\nTrackerCode.terminated_step_size_too_small: Trackint terminated since the step size was too small.\nTrackerCode.terminated_unknown: An unintended error occured. Please consider reporting an issue.\n\n\n\n\n\n","category":"module"},{"location":"tracker/#HomotopyContinuation2.is_success-Tuple{HomotopyContinuation2.TrackerCode.codes}","page":"Tracker","title":"HomotopyContinuation2.is_success","text":"is_success(code::TrackerCode.codes)\n\nReturns true if code indicates a success in the path tracking.\n\n\n\n\n\n","category":"method"},{"location":"tracker/#HomotopyContinuation2.is_tracking-Tuple{HomotopyContinuation2.TrackerCode.codes}","page":"Tracker","title":"HomotopyContinuation2.is_tracking","text":"is_tracking(code::TrackerCode.codes)\n\nReturns true if code indicates that the path tracking is not yet finished.\n\n\n\n\n\n","category":"method"},{"location":"tracker/#HomotopyContinuation2.is_invalid_startvalue-Tuple{HomotopyContinuation2.TrackerCode.codes}","page":"Tracker","title":"HomotopyContinuation2.is_invalid_startvalue","text":"is_invalid_startvalue(code::TrackerCode.codes)\n\nReturns true if code indicates that the path tracking got terminated since the start value was not a zero.\n\n\n\n\n\n","category":"method"},{"location":"tracker/#HomotopyContinuation2.is_terminated-Tuple{HomotopyContinuation2.TrackerCode.codes}","page":"Tracker","title":"HomotopyContinuation2.is_terminated","text":"is_terminated(code::TrackerCode.codes)\n\nReturns true if code indicates that the path tracking got terminated.\n\n\n\n\n\n","category":"method"},{"location":"start_systems/#Start-Systems-1","page":"Start systems","title":"Start Systems","text":"","category":"section"},{"location":"start_systems/#Total-Degree-1","page":"Start systems","title":"Total Degree","text":"","category":"section"},{"location":"start_systems/#","page":"Start systems","title":"Start systems","text":"total_degree","category":"page"},{"location":"start_systems/#HomotopyContinuation2.total_degree","page":"Start systems","title":"HomotopyContinuation2.total_degree","text":"total_degree(\n    F::System;\n    parameters = nothing,\n    gamma = cis(2π * rand()),\n    tracker_options = TrackerOptions(),\n    path_tracker_options = PathTrackerOptions(),\n)\n\nSolve the system F using a total degree homotopy. This returns a path tracker (PathTracker or OverdeterminedTracker) and an iterator to compute the start solutions. If the system F has declared variable_groups then a multi-homogeneous a start system following [Wam93] will be constructed.\n\n[Wam93]: An efficient start system for multi-homogeneous polynomial continuation, Wampler, C.W. Numer. Math. (1993) 66: 517. https://doi.org/10.1007/BF01385710\n\n\n\n\n\n","category":"function"},{"location":"start_systems/#Mixed-Volume-(Polyhedral-Homotopy)-1","page":"Start systems","title":"Mixed Volume (Polyhedral Homotopy)","text":"","category":"section"},{"location":"start_systems/#","page":"Start systems","title":"Start systems","text":"polyhedral\nPolyhedralTracker","category":"page"},{"location":"start_systems/#HomotopyContinuation2.polyhedral","page":"Start systems","title":"HomotopyContinuation2.polyhedral","text":"polyhedral(F::Union{System, AbstractSystem};\n    only_non_zero = false,\n    path_tracker_options = PathTrackerOptions(),\n    tracker_options = TrackerOptions())\n\nSolve the system F in two steps: first solve a generic system derived from the support of F using a polyhedral homotopy as proposed in [HS95], then perform a coefficient-parameter homotopy towards F. This returns a path tracker (PolyhedralTracker or OverdeterminedTracker) and an iterator to compute the start solutions.\n\nIf only_non_zero is true, then only the solutions with non-zero coordinates are computed. In this case the number of paths to track is equal to the mixed volume of the Newton polytopes of F.\n\nIf only_non_zero is false, then all isolated solutions of F are computed. In this case the number of paths to track is equal to the mixed volume of the convex hulls of supp(F_i)  0 where supp(F_i) is the support of F_i. See also [LW96].\n\nfunction polyhedral(\n    support::AbstractVector{<:AbstractMatrix},\n    coefficientss::AbstractVector{<:AbstractVector{<:Number}};\n    kwargs...,\n)\n\nIt is also possible to provide directly the support and coefficients of the system F to be solved.\n\n[HS95]: Birkett Huber and Bernd Sturmfels. “A Polyhedral Method for Solving Sparse Polynomial Systems.” Mathematics of Computation, vol. 64, no. 212, 1995, pp. 1541–1555\n\n[LW96]: T.Y. Li and Xiaoshen Wang. \"The BKK root count in C^n\". Math. Comput. 65, 216 (October 1996), 1477–1484.\n\nExample\n\nWe consider a system f which has in total 6 isolated solutions, but only 3 where all coordinates are non-zero.\n\n@var x y\nf = System([2y + 3 * y^2 - x * y^3, x + 4 * x^2 - 2 * x^3 * y])\ntracker, starts = polyhedral(f; only_non_zero = false)\n# length(starts) == 8\ncount(is_success, track.(tracker, starts)) # 6\n\ntracker, starts = polyhedral(f; only_non_zero = true)\n# length(starts) == 3\ncount(is_success, track.(tracker, starts)) # 3\n\n\n\n\n\n","category":"function"},{"location":"start_systems/#HomotopyContinuation2.PolyhedralTracker","page":"Start systems","title":"HomotopyContinuation2.PolyhedralTracker","text":"PolyhedralTracker <: AbstractPathTracker\n\nThis tracker realises the two step approach of the polyhedral homotopy. See also [polyhedral].\n\n\n\n\n\n","category":"type"},{"location":"start_systems/#Overdetermined-1","page":"Start systems","title":"Overdetermined","text":"","category":"section"},{"location":"start_systems/#","page":"Start systems","title":"Start systems","text":"OverdeterminedTracker\nsquare_up\nexcess_solution_check!\nexcess_solution_check","category":"page"},{"location":"start_systems/#HomotopyContinuation2.OverdeterminedTracker","page":"Start systems","title":"HomotopyContinuation2.OverdeterminedTracker","text":"OverdeterminedTracker(tracker::AbstractPathTracker, F::RandomizedSystem)\n\nWraps the given AbstractPathTracker tracker to apply excess_solution_check for the given randomized system F on each path result.\n\n\n\n\n\n","category":"type"},{"location":"start_systems/#HomotopyContinuation2.square_up","page":"Start systems","title":"HomotopyContinuation2.square_up","text":"square_up(F::Union{System, AbstractSystem})\n\nCreates the RandomizedSystem mathfrakR(F(x) N) where N is the number of variables of F.\n\n\n\n\n\n","category":"function"},{"location":"start_systems/#HomotopyContinuation2.excess_solution_check!","page":"Start systems","title":"HomotopyContinuation2.excess_solution_check!","text":"excess_solution_check!(path_result::PathResult,\n                       F::RandomizedSystem,\n                       newton_cache = NewtonCache(F.system))\n\nAssigns to the PathResult path_result the return_code :excess_solution if the path_result is a solution of the randomized system F but not of the polynomial system underlying F. This is performed by using Newton's method for non-singular solutions and comparing the residuals of the solutions for singular solutions.\n\n\n\n\n\n","category":"function"},{"location":"start_systems/#HomotopyContinuation2.excess_solution_check","page":"Start systems","title":"HomotopyContinuation2.excess_solution_check","text":"excess_solution_check(F::RandomizedSystem)\n\nReturns a function λ(::PathResult) which performs the excess solution check. The call excess_solution_check(F)(path_result) is identical to excess_solution_check!(F, path_result). See also excess_solution_check!.\n\n\n\n\n\n","category":"function"},{"location":"#Introduction-1","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"HomotopyContinuation.jl is a package for the numerical solution of systems of polynomial equations.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"This documentation is a purely technical description of the package functionality. You can find tutorials, examples, how-to guides and explanations on our homepage JuliaHomotopyContinuation.org.","category":"page"},{"location":"#Contents-1","page":"Introduction","title":"Contents","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"Problem formulation","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Pages = [\n    \"model_kit.md\",\n    \"linear_affine.md\",\n    \"systems_homotopies.md\",\n]\nDepth = 2","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Start Systems","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Pages = [\n    \"start_systems.md\",\n]\nDepth = 2","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Trackers","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Pages = [\n    \"path_tracker.md\",\n    \"tracker.md\",\n]\nDepth = 2","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Miscellaneous","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Pages = [\n    \"misc.md\",\n]\nDepth = 2","category":"page"},{"location":"result/#Results-1","page":"Results","title":"Results","text":"","category":"section"},{"location":"result/#","page":"Results","title":"Results","text":"A call to solve returns a Result:","category":"page"},{"location":"result/#","page":"Results","title":"Results","text":"Result\nseed(::Result)\npath_results(::Result)","category":"page"},{"location":"result/#HomotopyContinuation2.Result","page":"Results","title":"HomotopyContinuation2.Result","text":"Result\n\nThe result of solve. This is a wrapper around the results of each single path (PathResult) and it contains some additional information like a random seed to replicate the result.\n\n\n\n\n\n","category":"type"},{"location":"result/#HomotopyContinuation2.seed-Tuple{Result}","page":"Results","title":"HomotopyContinuation2.seed","text":"seed(::Result)\n\nReturns the seed to replicate the result.\n\n\n\n\n\n","category":"method"},{"location":"result/#HomotopyContinuation2.path_results-Tuple{Result}","page":"Results","title":"HomotopyContinuation2.path_results","text":"path_results(::Result)\n\nReturns the stored PathResults.\n\n\n\n\n\n","category":"method"},{"location":"result/#Filtering-results-and-solutions-1","page":"Results","title":"Filtering results and solutions","text":"","category":"section"},{"location":"result/#","page":"Results","title":"Results","text":"results\nsolutions\nBase.real(::Result)\nreal_solutions\nnonsingular\nsingular\nat_infinity\nfailed","category":"page"},{"location":"result/#HomotopyContinuation2.results","page":"Results","title":"HomotopyContinuation2.results","text":"results(\n    result;\n    only_real = false,\n    real_tol = 1e-6,\n    only_nonsingular = false,\n    only_singular = false,\n    singular_tol = 1e10,\n    only_finite = true,\n    multiple_results = false,\n)\nresults(f, result; options...)\n\nReturn all PathResults for which satisfy the given conditions and apply if provided the function f.\n\n\n\n\n\n","category":"function"},{"location":"result/#HomotopyContinuation2.solutions","page":"Results","title":"HomotopyContinuation2.solutions","text":"solutions(result; conditions...)\n\nReturns all solutions for which the given conditions apply, see results for the possible conditions.\n\nExample\n\njulia> @var x y\njulia> F = System([(x-2)y, y+x+3]);\njulia> solutions(solve(F))\n2-element Array{Array{Complex{Float64},1},1}:\n [2.0 + 0.0im, -5.0 + 0.0im]\n [-3.0 + 0.0im, 0.0 + 0.0im]\n\n\n\n\n\n","category":"function"},{"location":"result/#Base.real-Tuple{Result}","page":"Results","title":"Base.real","text":"real(result, tol=1e-6)\n\nGet all results where the solutions are real with the given tolerance tol. See is_real for details regarding the determination of 'realness'.\n\n\n\n\n\n","category":"method"},{"location":"result/#HomotopyContinuation2.real_solutions","page":"Results","title":"HomotopyContinuation2.real_solutions","text":"real_solutions(result; tol=1e-6, conditions...)\n\nReturn all real solution for which the given conditions apply. For the possible conditions see results. Note that only_real is always true and real_tol is now tol.\n\nExample\n\njulia> @var x y;\njulia> F = System([(x-2)y, y+x+3]);\njulia> real_solutions(solve(F))\n2-element Array{Array{Float64,1},1}:\n [2.0, -5.0]\n [-3.0, 0.0]\n\n\n\n\n\n","category":"function"},{"location":"result/#HomotopyContinuation2.nonsingular","page":"Results","title":"HomotopyContinuation2.nonsingular","text":"nonsingular(result; conditions...)\n\nReturn all PathResults for which the solution is non-singular. This is just a shorthand for results(R; only_nonsingular=true, conditions...). For the possible conditions see results.\n\n\n\n\n\n","category":"function"},{"location":"result/#HomotopyContinuation2.singular","page":"Results","title":"HomotopyContinuation2.singular","text":"singular(result; tol=1e10, multiple_results=false, kwargs...)\n\nReturn all [PathResult]s for which the solution is singular. A solution is labeled singular if the condition number is greater than singular_tol, or if the winding number is > 1. If multiple_results=false only one point from each cluster of multiple solutions is returned. If If multiple_results=true all singular solutions in R are returned. For the possible kwargs see results.\n\n\n\n\n\n","category":"function"},{"location":"result/#HomotopyContinuation2.at_infinity","page":"Results","title":"HomotopyContinuation2.at_infinity","text":"at_infinity(result)\n\nGet all results where the solutions is at infinity.\n\n\n\n\n\n","category":"function"},{"location":"result/#HomotopyContinuation2.failed","page":"Results","title":"HomotopyContinuation2.failed","text":"failed(result)\n\nGet all results where the path tracking failed.\n\n\n\n\n\n","category":"function"},{"location":"result/#Counting-1","page":"Results","title":"Counting","text":"","category":"section"},{"location":"result/#","page":"Results","title":"Results","text":"nresults\nnsolutions\nnreal\nnnonsingular\nnsingular\nnat_infinity\nnexcess_solutions\nnfailed","category":"page"},{"location":"result/#HomotopyContinuation2.nresults","page":"Results","title":"HomotopyContinuation2.nresults","text":"nresults(\n    result;\n    only_real = false,\n    real_tol = 1e-6,\n    only_nonsingular = false,\n    only_singular = false,\n    singular_tol = 1e10,\n    only_finite = true,\n    multiple_results = false,\n)\n\nCount the number of solutions which satisfy the corresponding conditions. See also results.\n\n\n\n\n\n","category":"function"},{"location":"result/#HomotopyContinuation2.nsolutions","page":"Results","title":"HomotopyContinuation2.nsolutions","text":"nsolutions(result)\n\nThe number of solutions.\n\n\n\n\n\n","category":"function"},{"location":"result/#HomotopyContinuation2.nreal","page":"Results","title":"HomotopyContinuation2.nreal","text":"nreal(result; tol=1e-6)\n\nThe number of real solutions. See also is_real.\n\n\n\n\n\n","category":"function"},{"location":"result/#HomotopyContinuation2.nnonsingular","page":"Results","title":"HomotopyContinuation2.nnonsingular","text":"nnonsingular(result; tol=1e-10)\n\nThe number of non-singular solutions. See also is_singular.\n\n\n\n\n\n","category":"function"},{"location":"result/#HomotopyContinuation2.nsingular","page":"Results","title":"HomotopyContinuation2.nsingular","text":"nsingular(\n    result;\n    singular_tol = 1e10,\n    counting_multiplicities = false,\n    kwargs...,\n)\n\nThe number of singular solutions. A solution is considered singular if its winding number is larger than 1 or the condition number is larger than tol. If counting_multiplicities=true the number of singular solutions times their multiplicities is returned.\n\n\n\n\n\n","category":"function"},{"location":"result/#HomotopyContinuation2.nat_infinity","page":"Results","title":"HomotopyContinuation2.nat_infinity","text":"nat_infinity(result)\n\nThe number of solutions at infinity.\n\n\n\n\n\n","category":"function"},{"location":"result/#HomotopyContinuation2.nexcess_solutions","page":"Results","title":"HomotopyContinuation2.nexcess_solutions","text":"nexcess_solutions(result)\n\nThe number of exess solutions. See also excess_solution_check.\n\n\n\n\n\n","category":"function"},{"location":"result/#HomotopyContinuation2.nfailed","page":"Results","title":"HomotopyContinuation2.nfailed","text":"nfailed(result)\n\nThe number of failed paths.\n\n\n\n\n\n","category":"function"},{"location":"result/#PathResult-1","page":"Results","title":"PathResult","text":"","category":"section"},{"location":"result/#","page":"Results","title":"Results","text":"PathResult\nsolution(::PathResult)\nis_success(::PathResult)\nis_at_infinity(::PathResult)\nis_excess_solution(::PathResult)\nis_failed(::PathResult)\nis_finite(::PathResult)\nis_singular(::PathResult)\nis_nonsingular(::PathResult)\nis_real(::PathResult)\naccuracy(::PathResult)\nresidual(::PathResult)\nsteps(::PathResult)\naccepted_steps(::PathResult)\nrejected_steps(::PathResult)\nwinding_number(::PathResult)\npath_number(::PathResult)\nstart_solution(::PathResult)\nmultiplicity(::PathResult)\nlast_path_point(::PathResult)\nvaluation(::PathResult)","category":"page"},{"location":"result/#HomotopyContinuation2.PathResult","page":"Results","title":"HomotopyContinuation2.PathResult","text":"PathResult\n\nA PathResult is the result of tracking of a path with track using an AbstractPathTracker ( e.g. PathTracker)\n\nFields\n\nGeneral solution information:\n\nreturn_code: See the list of return codes below.\nsolution::V: The solution vector.\nt::Float64: The value of t at which solution was computed. Note that if return_code is :at_infinity, then t is the value when this was decided.\naccuracy::Float64: An estimate the (relative) accuracy of the computed solution.\nresidual::Float64: The infinity norm of H(solution,t).\ncondition_jacobian::Float64: This is the condition number of the Jacobian at the solution. A high condition number indicates a singular solution or a solution on a positive dimensional component.\nwinding_number:Union{Nothing, Int}: The computed winding number. This is a lower bound on the multiplicity of the solution. It is nothing if the Cauchy endgame was not used.\nextended_precision::Bool: Indicate whether extended precision is necessary to achieve the accuracy of the solution.\npath_number::Union{Nothing,Int}: The number of the path (optional).\nstart_solution::Union{Nothing,V}: The start solution of the path (optional).\n\nPerformance information:\n\naccepted_steps::Int: The number of accepted steps during the path tracking.\nrejected_steps::Int: The number of rejected steps during the path tracking.\nextended_precision_used::Bool: Indicates whether extended precision was necessary to track the path.\n\nAdditional path and solution informations\n\nvaluation::Vector{Float64}: An approximation of the valuation of the Puiseux series expansion of x(t).\nlast_path_point::Tuple{V,Float64}: The last pair (xt) before the solution was computed. If the solution was computed with the Cauchy endgame, then the pair (xt) can be used to rerun the endgame.\n\nReturn codes\n\nPossible return codes are:\n\n:success: The PathTracker obtained a solution.\n:at_infinity: The PathTracker stopped the tracking of the path since it determined that that path is diverging towards infinity.\n:at_zero: The PathTracker stopped the tracking of the path since it determined that that path has a solution where at least one coordinate is 0. This only happens if the option zero_is_at_infinity is true.\n:excess_solution: For the solution of the system, the system had to be modified which introduced artificial solutions and this solution is one of them.\nvarious return codes indicating termination of the tracking\n\n\n\n\n\n","category":"type"},{"location":"result/#HomotopyContinuation2.solution-Tuple{PathResult}","page":"Results","title":"HomotopyContinuation2.solution","text":"solution(r::PathResult)\n\nGet the solution of the path.\n\n\n\n\n\n","category":"method"},{"location":"result/#HomotopyContinuation2.is_success-Tuple{PathResult}","page":"Results","title":"HomotopyContinuation2.is_success","text":"is_success(r::PathResult)\n\nChecks whether the path is successfull.\n\n\n\n\n\n","category":"method"},{"location":"result/#HomotopyContinuation2.is_at_infinity-Tuple{PathResult}","page":"Results","title":"HomotopyContinuation2.is_at_infinity","text":"is_at_infinity(r::PathResult)\n\nChecks whether the path goes to infinity.\n\n\n\n\n\n","category":"method"},{"location":"result/#HomotopyContinuation2.is_excess_solution-Tuple{PathResult}","page":"Results","title":"HomotopyContinuation2.is_excess_solution","text":"is_excess_solution(r::PathResult)\n\nChecks whether the path is successfull.\n\n\n\n\n\n","category":"method"},{"location":"result/#HomotopyContinuation2.is_failed-Tuple{PathResult}","page":"Results","title":"HomotopyContinuation2.is_failed","text":"is_failed(r::PathResult)\n\nChecks whether the path failed.\n\n\n\n\n\n","category":"method"},{"location":"result/#HomotopyContinuation2.is_finite-Tuple{PathResult}","page":"Results","title":"HomotopyContinuation2.is_finite","text":"is_finite(r::PathResult)\n\nChecks whether the path result is finite.\n\n\n\n\n\n","category":"method"},{"location":"result/#HomotopyContinuation2.is_singular-Tuple{PathResult}","page":"Results","title":"HomotopyContinuation2.is_singular","text":"is_singular(r::PathResult; tol::Float64 = 1e10)\n\nChecks whether the path result r is singular. This is true if the winding number is larger than  1 or if the condition number of the Jacobian is larger than tol.\n\n\n\n\n\n","category":"method"},{"location":"result/#HomotopyContinuation2.is_nonsingular-Tuple{PathResult}","page":"Results","title":"HomotopyContinuation2.is_nonsingular","text":"is_nonsingular(r::PathResult; tol::Float64 = 1e10)\n\nChecks whether the path result is non-singular. This is true if it is not singular.\n\n\n\n\n\n","category":"method"},{"location":"result/#HomotopyContinuation2.is_real-Tuple{PathResult}","page":"Results","title":"HomotopyContinuation2.is_real","text":"is_real(r::PathResult; tol::Float64 = 1e-6)\n\nWe consider a result as real if the infinity-norm of the imaginary part of the solution is at most tol.\n\n\n\n\n\n","category":"method"},{"location":"result/#HomotopyContinuation2.accuracy-Tuple{PathResult}","page":"Results","title":"HomotopyContinuation2.accuracy","text":"accuracy(r::PathResult)\n\nGet the accuracy of the solution. This is an estimate of the (relative) distance to the true solution.\n\n\n\n\n\n","category":"method"},{"location":"result/#HomotopyContinuation2.residual-Tuple{PathResult}","page":"Results","title":"HomotopyContinuation2.residual","text":"residual(r::PathResult)\n\nGet the residual of the solution.\n\n\n\n\n\n","category":"method"},{"location":"result/#HomotopyContinuation2.steps-Tuple{PathResult}","page":"Results","title":"HomotopyContinuation2.steps","text":"steps(r::PathResult)\n\nTotal number of steps the path tracker performed.\n\n\n\n\n\n","category":"method"},{"location":"result/#HomotopyContinuation2.accepted_steps-Tuple{PathResult}","page":"Results","title":"HomotopyContinuation2.accepted_steps","text":"accepted_steps(r::PathResult)\n\nTotal number of steps the path tracker accepted.\n\n\n\n\n\n","category":"method"},{"location":"result/#HomotopyContinuation2.rejected_steps-Tuple{PathResult}","page":"Results","title":"HomotopyContinuation2.rejected_steps","text":"rejected_steps(r::PathResult)\n\nTotal number of steps the path tracker rejected.\n\n\n\n\n\n","category":"method"},{"location":"result/#HomotopyContinuation2.winding_number-Tuple{PathResult}","page":"Results","title":"HomotopyContinuation2.winding_number","text":"winding_number(r::PathResult)\n\nGet the winding number of the solution of the path. Returns nothing if it wasn't computed.\n\n\n\n\n\n","category":"method"},{"location":"result/#HomotopyContinuation2.path_number-Tuple{PathResult}","page":"Results","title":"HomotopyContinuation2.path_number","text":"path_number(r::PathResult)\n\nGet the number of the path. Returns nothing if it wasn't provided.\n\n\n\n\n\n","category":"method"},{"location":"result/#HomotopyContinuation2.start_solution-Tuple{PathResult}","page":"Results","title":"HomotopyContinuation2.start_solution","text":"start_solution(r::PathResult)\n\nGet the start solution of the path.\n\n\n\n\n\n","category":"method"},{"location":"result/#HomotopyContinuation2.multiplicity-Tuple{PathResult}","page":"Results","title":"HomotopyContinuation2.multiplicity","text":"multiplicity(r::PathResult)\n\nGet the multiplicity of the solution of the path. Returns nothing if it wasn't computed.\n\n\n\n\n\n","category":"method"},{"location":"result/#HomotopyContinuation2.last_path_point-Tuple{PathResult}","page":"Results","title":"HomotopyContinuation2.last_path_point","text":"last_path_point(r::PathResult)\n\nReturns a tuple (x,t) containing the last zero of H(x, t) before the Cauchy endgame was used. Returns nothing if the endgame strategy was not invoked.\n\n\n\n\n\n","category":"method"},{"location":"result/#HomotopyContinuation2.valuation-Tuple{PathResult}","page":"Results","title":"HomotopyContinuation2.valuation","text":"valuation(r::PathResult)\n\nGet the computed valuation of the path.\n\n\n\n\n\n","category":"method"}]
}
