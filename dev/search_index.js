var documenterSearchIndex = {"docs":
[{"location":"linear_affine/#Linear-and-Affine-Subspaces-1","page":"Linear and Affine Subspaces","title":"Linear and Affine Subspaces","text":"","category":"section"},{"location":"linear_affine/#","page":"Linear and Affine Subspaces","title":"Linear and Affine Subspaces","text":"We provide built-in data structures to work with affine and linear subspaces L. L can be represented in either extrinsic coordinates x with L = x  Ax = b  or in intrinsic coordinates u with L=Bu+p  u.","category":"page"},{"location":"linear_affine/#Coordinates-1","page":"Linear and Affine Subspaces","title":"Coordinates","text":"","category":"section"},{"location":"linear_affine/#","page":"Linear and Affine Subspaces","title":"Linear and Affine Subspaces","text":"To specify which coordinates are given / expected the following can be used:","category":"page"},{"location":"linear_affine/#","page":"Linear and Affine Subspaces","title":"Linear and Affine Subspaces","text":"Coordinates\nIntrinsic\nExtrinsic","category":"page"},{"location":"linear_affine/#HomotopyContinuation2.Coordinates","page":"Linear and Affine Subspaces","title":"HomotopyContinuation2.Coordinates","text":"Coordinates\n\nA type used for encoding the used coordinates and for performing coordinate changes.\n\nCurrently supported coordinates are:\n\nIntrinsic\nExtrinsic\n\n\n\n\n\n","category":"type"},{"location":"linear_affine/#HomotopyContinuation2.Intrinsic","page":"Linear and Affine Subspaces","title":"HomotopyContinuation2.Intrinsic","text":"Intrinsic <: Coordinates\n\nIndicates the use of the intrinsic description of an affine subspace. See also AffineIntrinsic.\n\n\n\n\n\n","category":"constant"},{"location":"linear_affine/#HomotopyContinuation2.Extrinsic","page":"Linear and Affine Subspaces","title":"HomotopyContinuation2.Extrinsic","text":"Extrinsic <: Coordinates\n\nIndicates the use of the extrinsic description of an affine subspace. See also AffineExtrinsic.\n\n\n\n\n\n","category":"constant"},{"location":"linear_affine/#Affine-Subspace-1","page":"Linear and Affine Subspaces","title":"Affine Subspace","text":"","category":"section"},{"location":"linear_affine/#","page":"Linear and Affine Subspaces","title":"Linear and Affine Subspaces","text":"AffineSubspace\nAffineExtrinsic\nAffineIntrinsic","category":"page"},{"location":"linear_affine/#HomotopyContinuation2.AffineSubspace","page":"Linear and Affine Subspaces","title":"HomotopyContinuation2.AffineSubspace","text":"AffineSubspace(A, b)\n\nAn m-dimensional affine subspace L in n-dimensional space given by the extrinsic description L =  x  A x = b .\n\njulia> A = AffineSubspace([1 0 3; 2 1 3], [5, -2])\n1-dim. affine subspace {x|Ax=b} with eltype Float64:\nA:\n2×3 Array{Float64,2}:\n 1.0  0.0  3.0\n 2.0  1.0  3.0\nb:\n2-element Array{Float64,1}:\n  5.0\n -2.0\n\njulia> dim(A)\n1\n\njulia> codim(A)\n2\n\njulia> ambient_dim(A)\n3\n\nAn AffineSubspace holds always its extrinsic description, see also AffineIntrinsic, as well as its intrinsic description, see AffineExtrinsic.\n\njulia> intrinsic(A)\nAffineIntrinsic{Float64}:\nA:\n3×1 Array{Float64,2}:\n -0.6882472016116853\n  0.6882472016116853\n  0.22941573387056186\nb₀:\n3-element Array{Float64,1}:\n -3.0526315789473677\n -3.947368421052632\n  2.684210526315789\n\nAn AffineSubspace can be evaluated with either using Intrinsic or Extrinsic coordinates.\n\njulia> u = [0.5]\n1-element Array{Float64,1}:\n 0.5\n\njulia> x = A(u, Intrinsic)\n3-element Array{Float64,1}:\n -3.3967551797532103\n -3.6032448202467893\n  2.79891839325107\n\njulia> A(x, Extrinsic)\n  2-element Array{Float64,1}:\n   0.0\n   0.0\n\nTo change the used coordinates you can use coord_change.\n\njulia> coord_change(A, Extrinsic, Intrinsic, x)\n1-element Array{Float64,1}:\n 0.49999999999999994\n\n\n\n\n\n","category":"type"},{"location":"linear_affine/#HomotopyContinuation2.AffineExtrinsic","page":"Linear and Affine Subspaces","title":"HomotopyContinuation2.AffineExtrinsic","text":"AffineExtrinsic\n\nExtrinsic description of an m-dimensional affine subspace L in n-dimensional space. That is L =  x  A x = b .\n\n\n\n\n\n","category":"type"},{"location":"linear_affine/#HomotopyContinuation2.AffineIntrinsic","page":"Linear and Affine Subspaces","title":"HomotopyContinuation2.AffineIntrinsic","text":"AffineIntrinsic\n\nIntrinsic description of an m-dimensional affine subspace L in n-dimensional space. That is L =  u  A u + b₀ . Here, A and b₀ are in orthogonal coordinates. That is, the columns of A are orthonormal and A b₀ = 0.\n\n\n\n\n\n","category":"type"},{"location":"linear_affine/#Functions-1","page":"Linear and Affine Subspaces","title":"Functions","text":"","category":"section"},{"location":"linear_affine/#","page":"Linear and Affine Subspaces","title":"Linear and Affine Subspaces","text":"ambient_dim\ncodim\ncoord_change\ndim\nintrinsic\nextrinsic\ngeodesic\ngeodesic_distance\nrand_affine_subspace","category":"page"},{"location":"linear_affine/#HomotopyContinuation2.ambient_dim","page":"Linear and Affine Subspaces","title":"HomotopyContinuation2.ambient_dim","text":"ambient_dim(A::AffineSubspace)\n\nDimension of ambient space of the affine subspace A.\n\n\n\n\n\n","category":"function"},{"location":"linear_affine/#HomotopyContinuation2.codim","page":"Linear and Affine Subspaces","title":"HomotopyContinuation2.codim","text":"codim(A::AffineExtrinsic)\n\nCodimension of the affine subspace A.\n\n\n\n\n\ncodim(A::AffineIntrinsic)\n\nCodimension of the affine subspace A.\n\n\n\n\n\ncodim(A::AffineSubspace)\n\nCodimension of the affine subspace A.\n\n\n\n\n\n","category":"function"},{"location":"linear_affine/#HomotopyContinuation2.coord_change","page":"Linear and Affine Subspaces","title":"HomotopyContinuation2.coord_change","text":"coord_change(A::AffineSubspace, C₁::Coordinates, C₂::Coordinates, p)\n\nGiven an affine subspace A and a point p in coordinates C₁ compute the point x describing p in coordinates C₂.\n\nExample\n\njulia> A = AffineSubspace([1 0 3; 2 1 3], [5, -2]);\n\njulia> u = [1.25];\n\njulia> x = coord_change(A, Intrinsic, Extrinsic, u)\n3-element Array{Float64,1}:\n -3.9129405809619744\n -3.087059419038025\n  2.9709801936539915\n\njulia> A(x, Extrinsic)\n2-element Array{Float64,1}:\n 0.0\n 0.0\n\njulia> x - A(u, Intrinsic)\n3-element Array{Float64,1}:\n 0.0\n 0.0\n 0.0\n\n\n\n\n\n","category":"function"},{"location":"linear_affine/#HomotopyContinuation2.dim","page":"Linear and Affine Subspaces","title":"HomotopyContinuation2.dim","text":"dim(A::AffineExtrinsic)\n\nDimension of the affine subspace A.\n\n\n\n\n\ndim(A::AffineIntrinsic)\n\nDimension of the affine subspace A.\n\n\n\n\n\ndim(A::AffineSubspace)\n\nDimension of the affine subspace A.\n\n\n\n\n\n","category":"function"},{"location":"linear_affine/#HomotopyContinuation2.intrinsic","page":"Linear and Affine Subspaces","title":"HomotopyContinuation2.intrinsic","text":"intrinsic(A::AffineSubspace)\n\nObtain the intrinsic description of A, see also AffineIntrinsic.\n\n\n\n\n\n","category":"function"},{"location":"linear_affine/#HomotopyContinuation2.extrinsic","page":"Linear and Affine Subspaces","title":"HomotopyContinuation2.extrinsic","text":"extrinsic(A::AffineSubspace)\n\nObtain the extrinsic description of A, see also AffineExtrinsic.\n\n\n\n\n\n","category":"function"},{"location":"linear_affine/#HomotopyContinuation2.geodesic","page":"Linear and Affine Subspaces","title":"HomotopyContinuation2.geodesic","text":"geodesic(A::AffineSubspace, B::AffineSubspace)\n\nReturns the geodesic γ(t) connecting A and B in the Grassmanian Gr(k+1n+1) where k is the dimension of A and n is the ambient dimension. See also Corollary 4.3 in [LKK19].\n\n[LKK19]: Lim, Lek-Heng, Ken Sze-Wai Wong, and Ke Ye. \"Numerical algorithms on the affine Grassmannian.\" SIAM Journal on Matrix Analysis and Applications 40.2 (2019): 371-393\n\n\n\n\n\n","category":"function"},{"location":"linear_affine/#HomotopyContinuation2.geodesic_distance","page":"Linear and Affine Subspaces","title":"HomotopyContinuation2.geodesic_distance","text":"geodesic_distance(A::AffineSubspace, B::AffineSubspace)\n\nCompute the geodesic distance between A and B in the affine Grassmanian Graff(k, n) where k = dim(A) and n is the amebient dimension. This follows the derivation in [LKK19].\n\n[LKK19]: Lim, Lek-Heng, Ken Sze-Wai Wong, and Ke Ye. \"Numerical algorithms on the affine Grassmannian.\" SIAM Journal on Matrix Analysis and Applications 40.2 (2019): 371-393.\n\n\n\n\n\n","category":"function"},{"location":"linear_affine/#HomotopyContinuation2.rand_affine_subspace","page":"Linear and Affine Subspaces","title":"HomotopyContinuation2.rand_affine_subspace","text":"rand_affine_subspace(n::Integer; dim | codim, real = false)\n\nGenerate a random AffineSubspace with given dimension dim or codimension codim (one of them has to be provided) in ambient space of dimension n. If real is true, then the extrinsic description is real. The subspace is generated by drawing each entry of the extrinsic description indepdently from a normal distribuation using randn.\n\nExample\n\njulia> rand_affine_subspace(3; dim = 1)\n1-dim. affine subspace {x|Ax=b} with eltype Complex{Float64}:\nA:\n2×3 Array{Complex{Float64},2}:\n  -1.73825+1.27987im   -0.0871343+0.840408im  -0.551957+0.106397im\n -0.597132-0.343965im   -0.122543-0.172715im   -1.04949+0.370917im\nb:\n2-element Array{Complex{Float64},1}:\n  0.47083334430689394 + 0.8099804422599071im\n -0.12018696822943896 + 0.11723026326952792im\n\njulia> rand_affine_subspace(4; codim = 1)\n3-dim. affine subspace {x|Ax=b} with eltype Complex{Float64}:\nA:\n1×4 Array{Complex{Float64},2}:\n 0.345705+0.0893881im  -0.430867-0.663249im  0.979969-0.569378im  -0.29722-0.192493im\nb:\n1-element Array{Complex{Float64},1}:\n 0.7749708228192062 + 0.9762873764567546im\n\n\n\n\n\n","category":"function"},{"location":"path_tracker/#PathTracker-1","page":"PathTracker","title":"PathTracker","text":"","category":"section"},{"location":"path_tracker/#","page":"PathTracker","title":"PathTracker","text":"PathTracker is a data structure to track for a given AbstractHomotopy H(xt) a solution x from t₁  0 to 0, i.e.,  H(xt₁) = 0 and x with H(x0) = 0 is returned. This is done by following an implicitly defined path x(t) using Tracker. In contrast to Tracker this uses an endgame to handle diverging paths and singular solutions.","category":"page"},{"location":"path_tracker/#Constructor-and-Options-1","page":"PathTracker","title":"Constructor and Options","text":"","category":"section"},{"location":"path_tracker/#","page":"PathTracker","title":"PathTracker","text":"PathTracker\nPathTrackerOptions","category":"page"},{"location":"path_tracker/#HomotopyContinuation2.PathTracker","page":"PathTracker","title":"HomotopyContinuation2.PathTracker","text":"PathTracker(tracker::Tracker; options = PathTrackerOptions())\nPathTracker(H::AbstractHomotopy; options = PathTrackerOptions())\n\nA PathTracker combines a Tracker with an endgame. That is, while a Tracker assumes that the solution path is non-singular and convergent, the endgame allows to handle singular endpoints as well as diverging paths. To compute singular solutions the Cauchy endgame used, for divering paths a strategy based on the valuation of local Puiseux series expansion of the path is used. See [BT20] for a detailed description. By convention, a PathTracker always tracks from t=1 to t = 0. See PathTrackerOptions for the possible options.\n\n[BT20]: Breiding, P. and Timme, S. \"Tropical Endgame\", In preparation (2020)\n\n\n\n\n\n","category":"type"},{"location":"path_tracker/#HomotopyContinuation2.PathTrackerOptions","page":"PathTracker","title":"HomotopyContinuation2.PathTrackerOptions","text":"PathTrackerOptions(; options...)\n\nOptions controlling the behaviour of a PathTracker.\n\nOptions\n\nendgame_start::Float64 = 0.1: The point t in time where the endgame starts.\n\nEndgame parameters\n\nThese parameters control the behaviour during the endgame. See [BT20] for details.\n\nmin_cond_eg::Float64 = 1e6: The minimal condition number for which an endgame strategy is applied.\nat_infinity_check::Bool = true: Whether divering paths should be truncated.\nzero_is_at_infinity::Bool = false: Whether paths going to a solution where at least one coordinates is zero should also be considered diverging.\nval_finite_tol::Float64 = 1e-2: Tolerance on the valuation which has to be satisfied before the Cauchy endgame is started.\nmax_winding_number::Int = 20: The maximal winding number which is attempted in the Cauchy endgame.\nval_at_infinity_tol::Float64 = 1e-3: Tolerance on the valuation which has to be satisfied before a path is considered to diverge / go to infinity.\n\n[BT20]: Breiding, P. and Timme, S. \"Tropical Endgame\", In preparation (2020)\n\n\n\n\n\n","category":"type"},{"location":"path_tracker/#Tracking-1","page":"PathTracker","title":"Tracking","text":"","category":"section"},{"location":"path_tracker/#","page":"PathTracker","title":"PathTracker","text":"track(::PathTracker, ::AbstractVector, ::Real)","category":"page"},{"location":"path_tracker/#HomotopyContinuation2.track-Tuple{PathTracker,AbstractArray{T,1} where T,Real}","page":"PathTracker","title":"HomotopyContinuation2.track","text":"track(path_tracker::PathTracker, x::AbstractVector, t::Real = 1.0;\n      path_number = nothing, debug = false)\n\nTrack the given start solution x from t towards 0 using the given path_tracker. Returns a PathResult.\n\ntrack(path_tracker::PathTracker, r::PathResult, t::Real = 1.0;\n      path_number = nothing, debug = false)\n\nTrack solution(r) from t towards 0 using the given path_tracker.\n\n\n\n\n\n","category":"method"},{"location":"path_tracker/#PathResult-1","page":"PathTracker","title":"PathResult","text":"","category":"section"},{"location":"path_tracker/#","page":"PathTracker","title":"PathTracker","text":"PathResult\nsolution(::PathResult)\nis_success(::PathResult)\nis_at_infinity(::PathResult)\nis_excess_solution(::PathResult)\nis_failed(::PathResult)\nis_finite(::PathResult)\nis_singular(::PathResult)\nis_nonsingular(::PathResult)\nis_real(::PathResult)\naccuracy(::PathResult)\nsteps(::PathResult)\naccepted_steps(::PathResult)\nrejected_steps(::PathResult)\nwinding_number(::PathResult)\npath_number(::PathResult)\nstart_solution(::PathResult)\nmultiplicity(::PathResult)\nlast_path_point(::PathResult)\nvaluation(::PathResult)","category":"page"},{"location":"path_tracker/#HomotopyContinuation2.PathResult","page":"PathTracker","title":"HomotopyContinuation2.PathResult","text":"PathResult{V<:AbstractVector}\n\nA PathResult is the result of tracking of a path with track using a PathTracker.\n\nFields\n\nGeneral solution information:\n\nreturn_code: See the list of return codes below.\nsolution::V: The solution vector.\nt::Float64: The value of t at which solution was computed. Note that if return_code is :at_infinity, then t is the value when this was decided.\naccuracy::Float64: An estimate the (relative) accuracy of the computed solution.\ncondition_jacobian::Float64: This is the condition number of the Jacobian at the solution. A high condition number indicates a singular solution or a solution on a positive dimensional component.\nwinding_number:Union{Nothing, Int}: The computed winding number. This is a lower bound on the multiplicity of the solution. It is nothing if the Cauchy endgame was not used.\nextended_precision::Bool: Indicate whether extended precision is necessary to achieve the accuracy of the solution.\npath_number::Union{Nothing,Int}: The number of the path (optional).\nstart_solution::Union{Nothing,V}: The start solution of the path (optional).\n\nPerformance information:\n\naccepted_steps::Int: The number of accepted steps during the path tracking.\nrejected_steps::Int: The number of rejected steps during the path tracking.\nextended_precision_used::Bool: Indicates whether extended precision was necessary to track the path.\n\nAdditional path and solution informations\n\nvaluation::Vector{Float64}: An approximation of the valuation of the Puiseux series expansion of x(t).\nlast_path_point::Tuple{V,Float64}: The last pair (xt) before the solution was computed. If the solution was computed with the Cauchy endgame, then the pair (xt) can be used to rerun the endgame.\n\nReturn codes\n\nPossible return codes are:\n\n:success: The PathTracker obtained a solution.\n:at_infinity: The PathTracker stopped the tracking of the path since it determined that that path is diverging towards infinity.\n:at_zero: The PathTracker stopped the tracking of the path since it determined that that path has a solution where at least one coordinate is 0. This only happens if the option zero_is_at_infinity is true.\n:excess_solution: For the solution of the system, the system had to be modified which introduced artificial solutions and this solution is one of them.\nvarious return codes indicating termination of the tracking\n\n\n\n\n\n","category":"type"},{"location":"path_tracker/#HomotopyContinuation2.solution-Tuple{PathResult}","page":"PathTracker","title":"HomotopyContinuation2.solution","text":"solution(r::PathResult)\n\nGet the solution of the path.\n\n\n\n\n\n","category":"method"},{"location":"path_tracker/#HomotopyContinuation2.is_success-Tuple{PathResult}","page":"PathTracker","title":"HomotopyContinuation2.is_success","text":"is_success(r::PathResult)\n\nChecks whether the path is successfull.\n\n\n\n\n\n","category":"method"},{"location":"path_tracker/#HomotopyContinuation2.is_at_infinity-Tuple{PathResult}","page":"PathTracker","title":"HomotopyContinuation2.is_at_infinity","text":"is_at_infinity(r::PathResult)\n\nChecks whether the path goes to infinity.\n\n\n\n\n\n","category":"method"},{"location":"path_tracker/#HomotopyContinuation2.is_excess_solution-Tuple{PathResult}","page":"PathTracker","title":"HomotopyContinuation2.is_excess_solution","text":"is_excess_solution(r::PathResult)\n\nChecks whether the path is successfull.\n\n\n\n\n\n","category":"method"},{"location":"path_tracker/#HomotopyContinuation2.is_failed-Tuple{PathResult}","page":"PathTracker","title":"HomotopyContinuation2.is_failed","text":"is_failed(r::PathResult)\n\nChecks whether the path failed.\n\n\n\n\n\n","category":"method"},{"location":"path_tracker/#HomotopyContinuation2.is_finite-Tuple{PathResult}","page":"PathTracker","title":"HomotopyContinuation2.is_finite","text":"is_finite(r::PathResult)\n\nChecks whether the path result is finite.\n\n\n\n\n\n","category":"method"},{"location":"path_tracker/#HomotopyContinuation2.is_singular-Tuple{PathResult}","page":"PathTracker","title":"HomotopyContinuation2.is_singular","text":"is_singular(r::PathResult; tol::Float64 = 1e10)\n\nChecks whether the path result r is singular. This is true if the winding number is larger than  1 or if the condition number of the Jacobian is larger than tol.\n\n\n\n\n\n","category":"method"},{"location":"path_tracker/#HomotopyContinuation2.is_nonsingular-Tuple{PathResult}","page":"PathTracker","title":"HomotopyContinuation2.is_nonsingular","text":"is_nonsingular(r::PathResult; tol::Float64 = 1e10)\n\nChecks whether the path result is non-singular. This is true if it is not singular.\n\n\n\n\n\n","category":"method"},{"location":"path_tracker/#HomotopyContinuation2.is_real-Tuple{PathResult}","page":"PathTracker","title":"HomotopyContinuation2.is_real","text":"is_real(r::PathResult; tol::Float64 = 1e-6)\n\nWe consider a result as real if the infinity-norm of the imaginary part of the solution is at most tol.\n\n\n\n\n\n","category":"method"},{"location":"path_tracker/#HomotopyContinuation2.accuracy-Tuple{PathResult}","page":"PathTracker","title":"HomotopyContinuation2.accuracy","text":"accuracy(r::PathResult)\n\nGet the accuracy of the solution. This is an estimate of the (relative) distance to the true solution.\n\n\n\n\n\n","category":"method"},{"location":"path_tracker/#HomotopyContinuation2.steps-Tuple{PathResult}","page":"PathTracker","title":"HomotopyContinuation2.steps","text":"steps(r::PathResult)\n\nTotal number of steps the path tracker performed.\n\n\n\n\n\n","category":"method"},{"location":"path_tracker/#HomotopyContinuation2.accepted_steps-Tuple{PathResult}","page":"PathTracker","title":"HomotopyContinuation2.accepted_steps","text":"accepted_steps(r::PathResult)\n\nTotal number of steps the path tracker accepted.\n\n\n\n\n\n","category":"method"},{"location":"path_tracker/#HomotopyContinuation2.rejected_steps-Tuple{PathResult}","page":"PathTracker","title":"HomotopyContinuation2.rejected_steps","text":"rejected_steps(r::PathResult)\n\nTotal number of steps the path tracker rejected.\n\n\n\n\n\n","category":"method"},{"location":"path_tracker/#HomotopyContinuation2.winding_number-Tuple{PathResult}","page":"PathTracker","title":"HomotopyContinuation2.winding_number","text":"winding_number(r::PathResult)\n\nGet the winding number of the solution of the path. Returns nothing if it wasn't computed.\n\n\n\n\n\n","category":"method"},{"location":"path_tracker/#HomotopyContinuation2.path_number-Tuple{PathResult}","page":"PathTracker","title":"HomotopyContinuation2.path_number","text":"path_number(r::PathResult)\n\nGet the number of the path. Returns nothing if it wasn't provided.\n\n\n\n\n\n","category":"method"},{"location":"path_tracker/#HomotopyContinuation2.start_solution-Tuple{PathResult}","page":"PathTracker","title":"HomotopyContinuation2.start_solution","text":"start_solution(r::PathResult)\n\nGet the start solution of the path.\n\n\n\n\n\n","category":"method"},{"location":"path_tracker/#HomotopyContinuation2.multiplicity-Tuple{PathResult}","page":"PathTracker","title":"HomotopyContinuation2.multiplicity","text":"multiplicity(r::PathResult)\n\nGet the multiplicity of the solution of the path. Returns nothing if it wasn't computed.\n\n\n\n\n\n","category":"method"},{"location":"path_tracker/#HomotopyContinuation2.last_path_point-Tuple{PathResult}","page":"PathTracker","title":"HomotopyContinuation2.last_path_point","text":"last_path_point(r::PathResult)\n\nReturns a tuple (x,t) containing the last zero of H(x, t) before the Cauchy endgame was used. Returns nothing if the endgame strategy was not invoked.\n\n\n\n\n\n","category":"method"},{"location":"path_tracker/#HomotopyContinuation2.valuation-Tuple{PathResult}","page":"PathTracker","title":"HomotopyContinuation2.valuation","text":"valuation(r::PathResult)\n\nGet the computed valuation of the path.\n\n\n\n\n\n","category":"method"},{"location":"model_kit/#ModelKit-1","page":"ModelKit","title":"ModelKit","text":"","category":"section"},{"location":"model_kit/#","page":"ModelKit","title":"ModelKit","text":"ModelKit is the symbolic input and modeling language of HomotopyContinuation.jl. It is designed such that you can easily create an efficient formulation of your problem.","category":"page"},{"location":"model_kit/#Expressions-and-Variables-1","page":"ModelKit","title":"Expressions and Variables","text":"","category":"section"},{"location":"model_kit/#","page":"ModelKit","title":"ModelKit","text":"Expression\nVariable\n@var\n@unique_var","category":"page"},{"location":"model_kit/#HomotopyContinuation2.ModelKit.Expression","page":"ModelKit","title":"HomotopyContinuation2.ModelKit.Expression","text":"Expression <: Number\n\nA symbolic expression.\n\njulia> expr = (Variable(:x) + 1)^2\n(1 + x)^2\n\njulia> Expression(2)\n2\n\njulia> Expression(Variable(:x))\nx\n\n\n\n\n\n","category":"type"},{"location":"model_kit/#HomotopyContinuation2.ModelKit.Variable","page":"ModelKit","title":"HomotopyContinuation2.ModelKit.Variable","text":"Variable(name::Union{String,Symbol}, indices...) <: Number\n\nA data structure representing a variable.\n\njulia> Variable(:a)\na\n\njulia> Variable(:x, 1)\nx₁\n\njulia> Variable(:x, 10, 5)\nx₁₀₋₅\n\nEquality and ordering\n\nVariables are identified by their name and indices. That is, two variables are equal if and only if they have the same name and indices.\n\njulia> Variable(:a) == Variable(:a)\ntrue\n\njulia> Variable(:a, 1) == Variable(:a, 2)\nfalse\n\nSimilarly, variables are first ordered lexicographically by their name and then by their indices.\n\njulia> Variable(:a, 1) < Variable(:a, 2)\ntrue\n\njulia> Variable(:a, 1) < Variable(:b, 1)\ntrue\n\njulia> a = [Variable(:a, i, j) for i in 1:2, j in 1:2]\n2×2 Array{Variable,2}:\n a₁₋₁  a₁₋₂\n a₂₋₁  a₂₋₂\n\njulia> sort(vec(a))\n4-element Array{Variable,1}:\n a₁₋₁\n a₂₋₁\n a₁₋₂\n a₂₋₂\n\n\n\n\n\n","category":"type"},{"location":"model_kit/#HomotopyContinuation2.ModelKit.@var","page":"ModelKit","title":"HomotopyContinuation2.ModelKit.@var","text":"@var variable1 variable2 ...\n\nDeclare variables with the given names and automatically create the variable bindings. The macro supports indexing notation to create Arrays of variables.\n\nExamples\n\njulia> @var a b x[1:2] y[1:2,1:3]\n(a, b, Variable[x₁, x₂], Variable[y₁₋₁ y₁₋₂ y₁₋₃; y₂₋₁ y₂₋₂ y₂₋₃])\n\njulia> a\na\n\njulia> b\nb\n\njulia> x\n2-element Array{Variable,1}:\n x₁\n x₂\n\njulia> y\n2×3 Array{Variable,2}:\n y₁₋₁  y₁₋₂  y₁₋₃\n y₂₋₁  y₂₋₂  y₂₋₃\n\n\n\n\n\n","category":"macro"},{"location":"model_kit/#HomotopyContinuation2.ModelKit.@unique_var","page":"ModelKit","title":"HomotopyContinuation2.ModelKit.@unique_var","text":"@unique_var variable1 variable2\n\nThis is similar to @var with the only difference that the macro automatically changes the names of the variables to ensure uniqueness. However, the binding is still to the declared name. This is useful to ensure that there are no name collisions.\n\nExamples\n\njulia> @unique_var a b\n(a#591, b#592)\n\njulia> a\na#591\n\njulia> b\nb#592\n\n\n\n\n\n","category":"macro"},{"location":"model_kit/#Methods-1","page":"ModelKit","title":"Methods","text":"","category":"section"},{"location":"model_kit/#","page":"ModelKit","title":"ModelKit","text":"coefficients\ndegree\ndegrees(::AbstractVector{Expression})\ndifferentiate\ndense_poly\nevaluate\nexpand\nexponents_coefficients\nhorner\nnvariables(::Expression)\nmonomials\nsubs\nrand_poly\nto_number\nvariables(::Expression)","category":"page"},{"location":"model_kit/#HomotopyContinuation2.ModelKit.coefficients","page":"ModelKit","title":"HomotopyContinuation2.ModelKit.coefficients","text":"coefficients(f::Expression, vars::AbstractVector{Variable})\n\nReturn all coefficients of the given polynomial f for the given variables vars. This assumes that the expression f is already expanded, e.g., with expand.\n\n\n\n\n\n","category":"function"},{"location":"model_kit/#HomotopyContinuation2.ModelKit.degree","page":"ModelKit","title":"HomotopyContinuation2.ModelKit.degree","text":"degree(f::Expression, vars = variables(f); expanded = false)\n\nCompute the degree of the expression f  in vars. Unless expanded is true the expression is first expanded.\n\n\n\n\n\n","category":"function"},{"location":"model_kit/#HomotopyContinuation2.ModelKit.degrees-Tuple{AbstractArray{Expression,1}}","page":"ModelKit","title":"HomotopyContinuation2.ModelKit.degrees","text":"degrees(f::AbstractVector{Expression}, vars = variables(f); expanded = false)\n\nCompute the degrees of the expressions f in vars. Unless expanded is true the expressions are first expanded.\n\n\n\n\n\n","category":"method"},{"location":"model_kit/#HomotopyContinuation2.ModelKit.differentiate","page":"ModelKit","title":"HomotopyContinuation2.ModelKit.differentiate","text":"differentiate(expr::Expression, var::Variable, k = 1)\ndifferentiate(expr::AbstractVector{Expression}, var::Variable, k = 1)\n\nCompute the k-th derivative of expr with respect to the given variable var.\n\ndifferentiate(expr::Expression, vars::AbstractVector{Variable})\n\nCompute the partial derivatives of expr with respect to the given variable variables vars. Retuns a Vector containing the partial derivatives.\n\ndifferentiate(exprs::AbstractVector{Expression}, vars::AbstractVector{Variable})\n\nCompute the partial derivatives of exprs with respect to the given variable variables vars. Returns a Matrix where the each row contains the partial derivatives for a given expression.\n\n\n\n\n\n","category":"function"},{"location":"model_kit/#HomotopyContinuation2.ModelKit.dense_poly","page":"ModelKit","title":"HomotopyContinuation2.ModelKit.dense_poly","text":"dense_poly(vars::AbstractVector{Variable}, d::Integer; homogeneous::Bool = false)\n\nCreate a dense polynomial of degree d in the given variables variables where each coefficient is a parameter. Returns a tuple with the first argument being the polynomial and the second the parameters.\n\njulia> @var x y;\n\njulia> f, c = dense_poly([x, y], 2);\n\njulia> f\nc#262₁ + x*c#262₂ + x^2*c#262₄ + y*c#262₃ + y^2*c#262₆ + x*y*c#262₅\n\njulia> c\n6-element Array{Variable,1}:\n c#262₁\n c#262₂\n c#262₃\n c#262₄\n c#262₅\n c#262₆\n\n\n\n\n\n","category":"function"},{"location":"model_kit/#HomotopyContinuation2.ModelKit.evaluate","page":"ModelKit","title":"HomotopyContinuation2.ModelKit.evaluate","text":"evaluate(expr::Expression, subs...)\nevaluate(expr::AbstractArray{Expression}, subs...)\n\nEvaluate the given expression.\n\nExample\n\njulia> @var x y;\n\njulia> evaluate(x^2, x => 2)\n4\n\njulia> evaluate(x * y, [x,y] => [2, 3])\n6\n\njulia> evaluate([x^2, x * y], [x,y] => [2, 3])\n2-element Array{Int64,1}:\n 4\n 6\n\n# You can also use the callable syntax\njulia> [x^2, x * y]([x,y] => [2, 3])\n2-element Array{Int64,1}:\n 4\n 6\n\n\n\n\n\n","category":"function"},{"location":"model_kit/#HomotopyContinuation2.ModelKit.expand","page":"ModelKit","title":"HomotopyContinuation2.ModelKit.expand","text":"expand(e::Expression)\n\nExpand a given expression.\n\njulia> @var x y\n(x, y)\n\njulia> expand((x + y) ^ 2)\n2*x*y + x^2 + y^2\n\n\n\n\n\n","category":"function"},{"location":"model_kit/#HomotopyContinuation2.ModelKit.exponents_coefficients","page":"ModelKit","title":"HomotopyContinuation2.ModelKit.exponents_coefficients","text":"exponents_coefficients(f::Expression, vars::AbstractVector{Variable}; expanded = false)\n\nReturn a matrix M containing the exponents for all occuring terms (one term per column) and a vector c containing the corresponding coefficients. Expands the given expression f unless expanded = true.\n\n\n\n\n\n","category":"function"},{"location":"model_kit/#HomotopyContinuation2.ModelKit.horner","page":"ModelKit","title":"HomotopyContinuation2.ModelKit.horner","text":"horner(f::Expression, vars = variables(f))\n\nRewrite f using a multi-variate horner schema.\n\nExample\n\njulia> @var u v c[1:3]\n(u, v, Variable[c₁, c₂, c₃])\n\njulia> f = c[1] + c[2] * v + c[3] * u^2 * v^2 + c[3]u^3 * v\nc₁ + v*c₂ + u^2*v^2*c₃ + u^3*v*c₃\n\njulia> horner(f)\nc₁ + v*(c₂ + u^3*c₃ + u^2*v*c₃)\n\n\n\n\n\n","category":"function"},{"location":"model_kit/#HomotopyContinuation2.ModelKit.nvariables-Tuple{Expression}","page":"ModelKit","title":"HomotopyContinuation2.ModelKit.nvariables","text":"nvariables(expr::Expression; parameters = Variable[])\nnvariables(exprs::AbstractVector{Expression}; parameters = Variable[])\n\nObtain the number of variables used in the given expression not counting the the ones declared in parameters.\n\n\n\n\n\n","category":"method"},{"location":"model_kit/#HomotopyContinuation2.ModelKit.monomials","page":"ModelKit","title":"HomotopyContinuation2.ModelKit.monomials","text":"monomials(variables::AbstractVector{Variable}, d::Integer; homogeneous::Bool = false)\n\nCreate all monomials of a given degree in the given variables.\n\njulia> @var x y\n(x, y)\n\njulia> monomials([x,y], 2)\n6-element Array{Expression,1}:\nx^2\nx*y\ny^2\n  x\n  y\n  1\n\njulia> monomials([x,y], 2; homogeneous = true)\n3-element Array{Operation,1}:\n x ^ 2\n x * y\n y ^ 2\n\n\n\n\n\n","category":"function"},{"location":"model_kit/#HomotopyContinuation2.ModelKit.subs","page":"ModelKit","title":"HomotopyContinuation2.ModelKit.subs","text":"subs(expr::Expression, subsitutions::Pair...)\nsubs(exprs::AbstractVector{<:Expression}, subsitutions::Pair...)\n\nApply the given substitutions to the given expressions.\n\nExamples\n\n@var x y\n\njulia> subs(x^2, x => y)\ny ^ 2\n\njulia> subs(x * y, [x,y] => [x+2,y+2])\n(x + 2) * (y + 2)\n\njulia> subs([x + y, x^2], x => y + 2, y => x + 2)\n2-element Array{Expression,1}:\n 4 + x + y\n (2 + y)^2\n\n# You can also use the callable syntax\njulia> (x * y)([x,y] => [x+2,y+2])\n (x + 2) * (y + 2)\n\n\n\n\n\n","category":"function"},{"location":"model_kit/#HomotopyContinuation2.ModelKit.rand_poly","page":"ModelKit","title":"HomotopyContinuation2.ModelKit.rand_poly","text":"rand_poly(T = ComplexF64, vars::AbstractVector{Variable}, d::Integer; homogeneous::Bool = false)\n\nCreate a random dense polynomial of degree d in the given variables variables. Each coefficient is sampled independently via randn(T).\n\njulia> @var x y;\n\njulia> rand_poly(Float64, [x, y], 2)\n0.788764085756728 - 0.534507647623108*x - 0.778441366874946*y -\n 0.128891763280247*x*y + 0.878962738754971*x^2 + 0.550480741774464*y^2\n\n\n\n\n\n","category":"function"},{"location":"model_kit/#HomotopyContinuation2.ModelKit.to_number","page":"ModelKit","title":"HomotopyContinuation2.ModelKit.to_number","text":"to_number(x::Expression)\n\nTries to unpack the Expression x to a native number type.\n\n```julia-repl julia> x = to_number(Expression(2)) 2\n\njulia> typeof(x) Int64\n\n\n\n\n\n","category":"function"},{"location":"model_kit/#HomotopyContinuation2.ModelKit.variables-Tuple{Expression}","page":"ModelKit","title":"HomotopyContinuation2.ModelKit.variables","text":"variables(expr::Expression; parameters = Variable[])\nvariables(exprs::AbstractVector{Expression}; parameters = Variable[])\n\nObtain all variables used in the given expression up to the ones declared in parameters.\n\nExample\n\njulia> @var x y a;\njulia> variables(x^2 + y)\n2-element Array{Variable,1}:\n x\n y\n\njulia> variables([x^2 + a, y]; parameters = [a])\n2-element Array{Variable,1}:\n x\n y\n\n\n\n\n\n","category":"method"},{"location":"model_kit/#System-1","page":"ModelKit","title":"System","text":"","category":"section"},{"location":"model_kit/#","page":"ModelKit","title":"ModelKit","text":"System\ndegrees(F::System)\nexpressions(F::System)\nnparameters(::System)\nnvariables(::System)\nparameters(::System)\nvariables(::System)","category":"page"},{"location":"model_kit/#HomotopyContinuation2.ModelKit.System","page":"ModelKit","title":"HomotopyContinuation2.ModelKit.System","text":"System(exprs::AbstractVector{Expression};\n            variables = variables(exprssion),\n            parameters = Variable[])\nSystem(exprs, variables; parameters = Variable[])\n\nCreate a system from the given Expressions exprs. The variables determine also the variable ordering. The parameters argument allows to declare certain Variables as parameters.\n\nExamples\n\njulia> @var x y;\njulia> F = System([x^2, y^2]; variables = [y, x])\nSystem of length 2\n 2 variables: y, x\n\n x^2\n y^2\n\n# Systems are callable.\n# This evaluates F at y=2 and x=3\njulia> F([2, 3])\n2-element Array{Int64,1}:\n 9\n 4\n\nIt is also possible to declare parameters.\n\njulia> @var x y a b;\njulia> F = System([x^2 + a, y^2 + b]; variables = [y, x], parameters = [a, b])\nSystem of length 2\n 2 variables: y, x\n 2 parameters: a, b\n\n a + x^2\n b + y^2\n\njulia> F([2, 3], [5, -2])\n 2-element Array{Int64,1}:\n  14\n   2\n\n\n\n\n\n","category":"type"},{"location":"model_kit/#HomotopyContinuation2.ModelKit.degrees-Tuple{System}","page":"ModelKit","title":"HomotopyContinuation2.ModelKit.degrees","text":"degrees(F::System)\n\nReturn the degrees of the given system.\n\n\n\n\n\n","category":"method"},{"location":"model_kit/#HomotopyContinuation2.ModelKit.expressions-Tuple{System}","page":"ModelKit","title":"HomotopyContinuation2.ModelKit.expressions","text":"expressions(F::System)\n\nReturns the expressions of the given system F.\n\n\n\n\n\n","category":"method"},{"location":"model_kit/#HomotopyContinuation2.ModelKit.nparameters-Tuple{System}","page":"ModelKit","title":"HomotopyContinuation2.ModelKit.nparameters","text":"nparameters(F::System)\n\nReturns the number of parameters of the given system F.\n\n\n\n\n\n","category":"method"},{"location":"model_kit/#HomotopyContinuation2.ModelKit.nvariables-Tuple{System}","page":"ModelKit","title":"HomotopyContinuation2.ModelKit.nvariables","text":"nvariables(F::System)\n\nReturns the number of variables of the given system F.\n\n\n\n\n\n","category":"method"},{"location":"model_kit/#HomotopyContinuation2.ModelKit.parameters-Tuple{System}","page":"ModelKit","title":"HomotopyContinuation2.ModelKit.parameters","text":"parameters(F::System)\n\nReturns the parameters of the given system F.\n\n\n\n\n\n","category":"method"},{"location":"model_kit/#HomotopyContinuation2.ModelKit.variables-Tuple{System}","page":"ModelKit","title":"HomotopyContinuation2.ModelKit.variables","text":"variables(F::System)\n\nReturns the variables of the given system F.\n\n\n\n\n\n","category":"method"},{"location":"model_kit/#Homotopy-1","page":"ModelKit","title":"Homotopy","text":"","category":"section"},{"location":"model_kit/#","page":"ModelKit","title":"ModelKit","text":"Homotopy\nexpressions(::Homotopy)\nnparameters(::Homotopy)\nnvariables(::Homotopy)\nparameters(::Homotopy)\nvariables(::Homotopy)","category":"page"},{"location":"model_kit/#HomotopyContinuation2.ModelKit.Homotopy","page":"ModelKit","title":"HomotopyContinuation2.ModelKit.Homotopy","text":"Homotopy(exprs, vars, t, parameters = Variable[])\n\nCreate a homotopy H(vars,t) from the given Expressions exprs where vars are the given variables and t is the dedicated variable parameterizing the family of systems. The parameters argument allows to declare certain Variables as parameters.\n\nExample\n\njulia> @var x y t;\n\njulia> H = Homotopy([x + t, y + 2t], [y, x], t)\nHomotopy in t of length 2\n 2 variables: y, x\n\n t + x\n 2*t + y\n\njulia> H([2, 3], 0)\n2-element Array{Int64,1}:\n 3\n 2\n\n\njulia> H([2, 3], 1)\n2-element Array{Int64,1}:\n 4\n 4\n\nIt is also possible to declare additional variables.\n\njulia> @var x y t a b;\njulia> H = Homotopy([x^2 + t*a, y^2 + t*b], [x, y], t, [a, b])\nHomotopy in t of length 2\n 2 variables: x, y\n 2 parameters: a, b\n\n a*t + x^2\n b*t + y^2\njulia> H([2, 3], 1, [5, 2])\n2-element Array{Int64,1}:\n 9\n 11\n\n\n\n\n\n","category":"type"},{"location":"model_kit/#HomotopyContinuation2.ModelKit.expressions-Tuple{Homotopy}","page":"ModelKit","title":"HomotopyContinuation2.ModelKit.expressions","text":"expressions(H::Homotopy)\n\nReturns the expressions of the given homotopy H.\n\n\n\n\n\n","category":"method"},{"location":"model_kit/#HomotopyContinuation2.ModelKit.nparameters-Tuple{Homotopy}","page":"ModelKit","title":"HomotopyContinuation2.ModelKit.nparameters","text":"nparameters(H::Homotopy)\n\nReturns the number of parameters of the given homotopy H.\n\n\n\n\n\n","category":"method"},{"location":"model_kit/#HomotopyContinuation2.ModelKit.nvariables-Tuple{Homotopy}","page":"ModelKit","title":"HomotopyContinuation2.ModelKit.nvariables","text":"nvariables(H::Homotopy)\n\nReturns the number of variables of the given homotopy H.\n\n\n\n\n\n","category":"method"},{"location":"model_kit/#HomotopyContinuation2.ModelKit.parameters-Tuple{Homotopy}","page":"ModelKit","title":"HomotopyContinuation2.ModelKit.parameters","text":"parameters(H::Homotopy)\n\nReturns the parameters of the given homotopy H.\n\n\n\n\n\n","category":"method"},{"location":"model_kit/#HomotopyContinuation2.ModelKit.variables-Tuple{Homotopy}","page":"ModelKit","title":"HomotopyContinuation2.ModelKit.variables","text":"variables(H::Homotopy)\n\nReturns the variables of the given homotopy H.\n\n\n\n\n\n","category":"method"},{"location":"systems_homotopies/#Systems-and-Homotopies-1","page":"Systems and Homotopies","title":"Systems and Homotopies","text":"","category":"section"},{"location":"systems_homotopies/#","page":"Systems and Homotopies","title":"Systems and Homotopies","text":"Systems (AbstractSystem) and homotopies (AbstractHomotopy) are used for the numerical computations.","category":"page"},{"location":"systems_homotopies/#Systems-1","page":"Systems and Homotopies","title":"Systems","text":"","category":"section"},{"location":"systems_homotopies/#","page":"Systems and Homotopies","title":"Systems and Homotopies","text":"Systems (AbstractSystem) are the basic building blocks of homotopies.","category":"page"},{"location":"systems_homotopies/#","page":"Systems and Homotopies","title":"Systems and Homotopies","text":"AbstractSystem","category":"page"},{"location":"systems_homotopies/#HomotopyContinuation2.AbstractSystem","page":"Systems and Homotopies","title":"HomotopyContinuation2.AbstractSystem","text":"AbstractSystem\n\nAn abstract type representing a polynomial system F(x).\n\nThe following systems are available:\n\nModelKitSystem\nRandomizedSystem\n\n\n\n\n\n","category":"type"},{"location":"systems_homotopies/#ModelKitSystem-1","page":"Systems and Homotopies","title":"ModelKitSystem","text":"","category":"section"},{"location":"systems_homotopies/#","page":"Systems and Homotopies","title":"Systems and Homotopies","text":"ModelKitSystem","category":"page"},{"location":"systems_homotopies/#HomotopyContinuation2.ModelKitSystem","page":"Systems and Homotopies","title":"HomotopyContinuation2.ModelKitSystem","text":"ModelKitSystem(F:System, parameters = nothing)\n\nConstruct a system from the given System F with the given parameters fixed. The difference to F is that this compiles a straight line programm for the fast evaluation of F and that ModelKitSystem <: AbstractSystem.\n\n\n\n\n\n","category":"type"},{"location":"systems_homotopies/#RandomizedSystem-1","page":"Systems and Homotopies","title":"RandomizedSystem","text":"","category":"section"},{"location":"systems_homotopies/#","page":"Systems and Homotopies","title":"Systems and Homotopies","text":"RandomizedSystem","category":"page"},{"location":"systems_homotopies/#HomotopyContinuation2.RandomizedSystem","page":"Systems and Homotopies","title":"HomotopyContinuation2.RandomizedSystem","text":"RandomizedSystem(F::Union{System,AbstractSystem}, k::Integer) <: AbstractSystem\n\nGiven a n  N system F with n  N this constructs the system mathfrakR(F k)(x) = I AF(x) where I is a k  k identity matrix and A is random complex k  n matrix. See Chapter 13.5 in [SW05] for more details.\n\nRandomizedSystem(F::Union{System,AbstractSystem}, A::Matrix{ComplexF64}) <: AbstractSystem\n\nExplicitly provide the used randomization matrix A.\n\n[SW05]: Sommese, A. J., & Wampler, C. W. (2005). The Numerical Solution of Systems of Polynomials Arising in Engineering and Science. World Scientific.\n\n\n\n\n\n","category":"type"},{"location":"systems_homotopies/#Homotopies-1","page":"Systems and Homotopies","title":"Homotopies","text":"","category":"section"},{"location":"systems_homotopies/#","page":"Systems and Homotopies","title":"Systems and Homotopies","text":"Homotopies (AbstractHomotopy) are at the heart of homotopy continuation. A homotopy is a parameterized family H(xt) of polynomial systems. By convention, homotopies are tracked from t=1 to t=0, i.e., H(x1) is considered the start system and H(x0) is the target system.","category":"page"},{"location":"systems_homotopies/#","page":"Systems and Homotopies","title":"Systems and Homotopies","text":"AbstractHomotopy","category":"page"},{"location":"systems_homotopies/#HomotopyContinuation2.AbstractHomotopy","page":"Systems and Homotopies","title":"HomotopyContinuation2.AbstractHomotopy","text":"AbstractHomotopy\n\nAn abstract type representing a homotopy H(xt).\n\nThe following homotopies are available:\n\nAffineChartHomotopy\nAffineSubspaceHomotopy\nModelKitHomotopy\nParameterHomotopy\nStraightLineHomotopy\n\n\n\n\n\n","category":"type"},{"location":"systems_homotopies/#AffineChartHomotopy-1","page":"Systems and Homotopies","title":"AffineChartHomotopy","text":"","category":"section"},{"location":"systems_homotopies/#","page":"Systems and Homotopies","title":"Systems and Homotopies","text":"AffineChartHomotopy\non_affine_chart","category":"page"},{"location":"systems_homotopies/#HomotopyContinuation2.AffineChartHomotopy","page":"Systems and Homotopies","title":"HomotopyContinuation2.AffineChartHomotopy","text":"AffineChartHomotopy(H::AbstractHomotopy, v::PVector{T,N})\n\nGiven a homotopy H(xt) (ℙ^m_1    ℙ^m_N)  ℂ  ℂⁿ this creates a new affine homotopy H which operates on the affine chart defined by the vector v  ℙ^m_1    ℙ^m_N and the augmented conditions vᵀx = 1.\n\n\n\n\n\n","category":"type"},{"location":"systems_homotopies/#HomotopyContinuation2.on_affine_chart","page":"Systems and Homotopies","title":"HomotopyContinuation2.on_affine_chart","text":"on_affine_chart(H::AbstractHomotopy, proj_dims::NTuple{N,Int}) where {N}\n\nConstruct an AffineChartHomotopy on a randomly generated chart v. Each entry is drawn idepdently from a univariate normal distribution.\n\n\n\n\n\n","category":"function"},{"location":"systems_homotopies/#AffineSubspaceHomotopy-1","page":"Systems and Homotopies","title":"AffineSubspaceHomotopy","text":"","category":"section"},{"location":"systems_homotopies/#","page":"Systems and Homotopies","title":"Systems and Homotopies","text":"AffineSubspaceHomotopy\nset_subspaces!","category":"page"},{"location":"systems_homotopies/#HomotopyContinuation2.AffineSubspaceHomotopy","page":"Systems and Homotopies","title":"HomotopyContinuation2.AffineSubspaceHomotopy","text":"AffineSubspaceHomotopy(F::System, V::AffineSubspace, W::AffineSubspace)\nAffineSubspaceHomotopy(F::AbstractSystem, V::AffineSubspace, W::AffineSubspace)\n\nCreates a homotopy H(xt) = (F  γ(t))(x) where γ(t) is a family of affine subspaces such that H(x1) = (F  V)(x) and H(x0) = (F  W)(x). Here γ(t) is the geodesic between V and W in the affine Grassmanian, i.e., it is the curve of minimal length connecting V and W. See also AffineSubspace and geodesic and the references therein.\n\n\n\n\n\n","category":"type"},{"location":"systems_homotopies/#HomotopyContinuation2.set_subspaces!","page":"Systems and Homotopies","title":"HomotopyContinuation2.set_subspaces!","text":"set_subspaces!(H::AffineSubspaceHomotopy, start::AffineSubspace, target::AffineSubspace)\n\nUpdate the homotopy H to track from the affine subspace start to target.\n\n\n\n\n\n","category":"function"},{"location":"systems_homotopies/#ModelKitHomotopy-1","page":"Systems and Homotopies","title":"ModelKitHomotopy","text":"","category":"section"},{"location":"systems_homotopies/#","page":"Systems and Homotopies","title":"Systems and Homotopies","text":"ModelKitHomotopy","category":"page"},{"location":"systems_homotopies/#HomotopyContinuation2.ModelKitHomotopy","page":"Systems and Homotopies","title":"HomotopyContinuation2.ModelKitHomotopy","text":"ModelKitHomotopy(H::Homotopy, parameters = nothing)\n\nConstruct a homotopy from the given homotopy H with the given parameters fixed. The difference to H is that this compiles a straight line programm for the fast evaluation of H and that ModelKitHomotopy <: AbstractHomotopy.\n\n\n\n\n\n","category":"type"},{"location":"systems_homotopies/#StraightLineHomotopy-1","page":"Systems and Homotopies","title":"StraightLineHomotopy","text":"","category":"section"},{"location":"systems_homotopies/#","page":"Systems and Homotopies","title":"Systems and Homotopies","text":"ParameterHomotopy","category":"page"},{"location":"systems_homotopies/#HomotopyContinuation2.ParameterHomotopy","page":"Systems and Homotopies","title":"HomotopyContinuation2.ParameterHomotopy","text":"ParameterHomotopy(F::Union{AbstractSystem,System}; start_parameters, target_parameters)\nParameterHomotopy(F::Union{AbstractSystem,System}, start_parameters, target_parameters)\n\nConstruct the parameter homotopy H(xt) = F(x t p + (1 - t) q) where p is start_parameters and q is target_parameters.\n\n\n\n\n\n","category":"type"},{"location":"systems_homotopies/#StraightLineHomotopy-2","page":"Systems and Homotopies","title":"StraightLineHomotopy","text":"","category":"section"},{"location":"systems_homotopies/#","page":"Systems and Homotopies","title":"Systems and Homotopies","text":"StraightLineHomotopy","category":"page"},{"location":"systems_homotopies/#HomotopyContinuation2.StraightLineHomotopy","page":"Systems and Homotopies","title":"HomotopyContinuation2.StraightLineHomotopy","text":"StraightLineHomotopy(G::System, F::System)\nStraightLineHomotopy(G::AbstractSystem, F::AbstractSystem)\n\nConstructs the straight line homotopy H(x t) = tG(x) + (1-t)F(x).\n\n\n\n\n\n","category":"type"},{"location":"misc/#Miscellaneous-1","page":"Miscellaneous","title":"Miscellaneous","text":"","category":"section"},{"location":"misc/#Newton's-method-1","page":"Miscellaneous","title":"Newton's method","text":"","category":"section"},{"location":"misc/#","page":"Miscellaneous","title":"Miscellaneous","text":"newton\nNewtonResult\nis_success(::NewtonResult)\nNewtonCache","category":"page"},{"location":"misc/#HomotopyContinuation2.newton","page":"Miscellaneous","title":"HomotopyContinuation2.newton","text":"newton(\n    F::AbstractSystem,\n    x₀::AbstractVector,\n    norm::AbstractNorm = InfNorm(),\n    cache::NewtonCache = NewtonCache(F, x₀);\n    options...\n)\n\nAn implemenetation of a local Newton's method with various options to specify convergence criteria. Returns a NewtonResult. The computations are always performed in complex arithmetic with double precision, i.e., using Complex{Float64}. The optional cache argument pre-allocates the necessary memory. This is useful if the method is called repeatedly.\n\nOptions\n\nabs_tol::Float64 = 1e-8: The method is declared converged if norm(xᵢ₊₁ - xᵢ) < abs_tol.\nrel_tol::Float64 = abs_tol: The method is declared converged if norm(xᵢ₊₁ - xᵢ) < abs_tol * norm(x₀).\nmax_iters::Int = 20: The maximal number of iterations.\nextended_precision::Bool = false: An optional use of extended precision for the evaluation of F(x). This can increase the achievable accuracy.\ncontraction_factor::Float64 = 1.0: The Newton updates have to satisfy xᵢ₁ - xᵢ  a^2^(i-1)x₁ - x₀ for i  1 where a is contraction_factor.\nmin_contraction_iters::Int = typemax(Int):  The minimal number of iterations the contraction_factor has to be satisfied. If after min_contraction_iters many iterations the contraction factor is not satisfied the step is accepted anyway.\nmax_abs_norm_first_update::Float64 = Inf: The initial guess x₀ is rejected if norm(x₁ - x₀) >  max_abs_norm_first_update\nmax_rel_norm_first_update::Float64 = max_abs_norm_first_update: The initial guess x₀ is rejected if norm(x₁ - x₀) >  max_rel_norm_first_update * norm(x₀)\n\n\n\n\n\n","category":"function"},{"location":"misc/#HomotopyContinuation2.NewtonResult","page":"Miscellaneous","title":"HomotopyContinuation2.NewtonResult","text":"NewtonResult\n\nResult returned by newton.\n\nFields\n\nreturn_code::Symbol: Can be :success, :rejected or :max_iters.\nx::Vector{ComplexF64}: The last value obtained.\naccuracy::Float64: Estimate of the distance of x to a true zero.\niters::Int Number of iterations performed.\ncontraction_ratio::Float64: The value |xᵢ - xᵢ₋₁| / |xᵢ₋₁ - xᵢ₋₂|.\n\n\n\n\n\n","category":"type"},{"location":"misc/#HomotopyContinuation2.is_success-Tuple{NewtonResult}","page":"Miscellaneous","title":"HomotopyContinuation2.is_success","text":"is_success(R::NewtonResult)\n\nReturns true if the newton was successfull.\n\n\n\n\n\n","category":"method"},{"location":"misc/#HomotopyContinuation2.NewtonCache","page":"Miscellaneous","title":"HomotopyContinuation2.NewtonCache","text":"NewtonCache(F::AbstractSystem)\n\nPre-allocates the necessary memory for newton.\n\n\n\n\n\n","category":"type"},{"location":"misc/#Norms-1","page":"Miscellaneous","title":"Norms","text":"","category":"section"},{"location":"misc/#","page":"Miscellaneous","title":"Miscellaneous","text":"AbstractNorm\nInfNorm\nWeightedNorm\ndistance(u, v, ::AbstractNorm)\nnorm(u, ::AbstractNorm)\ninit!(::WeightedNorm, ::AbstractVector)\nupdate!(::WeightedNorm, ::AbstractVector)","category":"page"},{"location":"misc/#HomotopyContinuation2.AbstractNorm","page":"Miscellaneous","title":"HomotopyContinuation2.AbstractNorm","text":"AbstractNorm\n\nAn AbstractNorm represents any norm of a vector space. All norms are callable. norm(x) computes the norm of x and norm(x,y) computes the distance norm(x - y).\n\n\n\n\n\n","category":"type"},{"location":"misc/#HomotopyContinuation2.InfNorm","page":"Miscellaneous","title":"HomotopyContinuation2.InfNorm","text":"InfNorm <: AbstractNorm\n\nThe infinity or maximum norm.\n\n\n\n\n\n","category":"type"},{"location":"misc/#HomotopyContinuation2.WeightedNorm","page":"Miscellaneous","title":"HomotopyContinuation2.WeightedNorm","text":"WeightedNorm(d::AbstractVector, norm::AbstractNorm; options...)\nWeightedNorm(norm::AbstractNorm, n::Integer; options...)\nWeightedNorm(norm::AbstractNorm, x::AbstractVector; options...)\n\nA WeightedNorm represents a weighted variant of norm norm of a n-dimensional vector space.A norm||x||is weighted by introducing a vector of additional weightsdsuch that the new norm is||D⁻¹x||whereDis the diagonal matrix with diagonald. The WeightedNorm is desigened to change the weights dynamically by using init!(::WeightedNorm, x) and update!(::WeightedNorm, x). The weights are there constructed such that D¹x  10. The weights can be accessed and changed by indexing.\n\nOptions\n\nscale_min = sqrt(eps()): The minimal size of dᵢ is scale_min time the (weighted) norm of x.\nscale_abs_min = min(scale_min^2, 200 * sqrt(eps())): The absolute minimal size of dᵢ.\nscale_max = 1.0 / eps() / sqrt(2): The absolute maximal size of dᵢ\n\n\n\n\n\n","category":"type"},{"location":"misc/#HomotopyContinuation2.distance-Tuple{Any,Any,AbstractNorm}","page":"Miscellaneous","title":"HomotopyContinuation2.distance","text":"distance(u, v, norm::AbstractNorm)\n\nCompute the distance ||u-v|| with respect to the given norm norm.\n\n\n\n\n\n","category":"method"},{"location":"misc/#LinearAlgebra.norm-Tuple{Any,AbstractNorm}","page":"Miscellaneous","title":"LinearAlgebra.norm","text":"norm(u, norm::AbstractNorm)\n\nCompute the norm ||u|| with respect to the given norm norm.\n\n\n\n\n\n","category":"method"},{"location":"misc/#HomotopyContinuation2.init!-Tuple{WeightedNorm,AbstractArray{T,1} where T}","page":"Miscellaneous","title":"HomotopyContinuation2.init!","text":"init!(w::WeightedNorm, x::AbstractVector)\n\nSetup the weighted norm w for x.\n\n\n\n\n\n","category":"method"},{"location":"misc/#HomotopyContinuation2.update!-Tuple{WeightedNorm,AbstractArray{T,1} where T}","page":"Miscellaneous","title":"HomotopyContinuation2.update!","text":"update!(w::WeightedNorm, x::AbstractVector)\n\nUpdate the weighted norm w for x, this will interpolate between the previous weights and the norm of x.\n\n\n\n\n\n","category":"method"},{"location":"misc/#Debugging-1","page":"Miscellaneous","title":"Debugging","text":"","category":"section"},{"location":"misc/#","page":"Miscellaneous","title":"Miscellaneous","text":"path_info","category":"page"},{"location":"misc/#HomotopyContinuation2.path_info","page":"Miscellaneous","title":"HomotopyContinuation2.path_info","text":"path_info(tracker::Tracker, x₀, t₁ = 1.0, t₀ = 0.0; debug::Bool = false, kwargs...)\n\nTrack a path using the given tracker and start value x₀. This returns a struct containing detailed information about the tracked path.\n\n\n\n\n\n","category":"function"},{"location":"tracker/#Tracker-1","page":"Trackers","title":"Tracker","text":"","category":"section"},{"location":"tracker/#","page":"Trackers","title":"Trackers","text":"Tracker is a data structure to track for a given AbstractHomotopy H(xt) a solution x from t₁  ℂ to t₀  ℂ, i.e.,  H(xt₁) = 0 and x with H(xt₀) = 0 is returned. This is done by following an implicitly defined smooth path x(t) using a predictor-corrector scheme. In particular, it is assumed that for all t on the line segment between t₁ and t₀ the Jacobian H_x(x(t)t) has full column-rank. The algorithm uses as an predictor a Padé approximant of order (2,1) and as a corrector Newton's method. The details of the algorithm are described in the article [Tim20].","category":"page"},{"location":"tracker/#Constructor-and-Options-1","page":"Trackers","title":"Constructor and Options","text":"","category":"section"},{"location":"tracker/#","page":"Trackers","title":"Trackers","text":"Tracker\nTrackerOptions\nTrackerParameters\nDEFAULT_TRACKER_PARAMETERS\nCONSERVATIVE_TRACKER_PARAMETERS\nFAST_TRACKER_PARAMETERS","category":"page"},{"location":"tracker/#HomotopyContinuation2.Tracker","page":"Trackers","title":"HomotopyContinuation2.Tracker","text":"Tracker(H::AbstractHomotopy;\n        automatic_differentiation = 3,\n        options = TrackerOptions(),\n        weighted_norm_options = WeightedNormOptions())\n\nConstruct a tracker for the given homotopy H. The algorithm computes along the path x(t) the local derivatives up to order 4. The value automatic_differentiation determines which up to which one teh derivative is computed using automatic differentiation. Otherwise numerical differentiation is used. The automatic differentiation results in additional compilation time, however for numerically challenging paths it is strongly recommended to use automatic_differentiation = 3. For options see also TrackerOptions. The algorithm uses as a weighted infinity norm to measure distances. See also WeightedNorm.\n\n[Tim20]: Timme, S. \"Mixed Precision Path Tracking for Polynomial Homotopy Continuation\". arXiv:1902.02968 (2020)\n\nExample\n\nWe want to solve the system\n\n@var x y t\nF = System([x^2 + y^2 - 3, 2x^2 + 0.5x*y + 3y^2 - 2])\n\nusing a total degree homotopy and Tracker.\n\n# construct start system and homotopy\nG = System(im * [x^2 - 1, y^2 - 1])\nH = StraightLineHomotopy(G, F)\nstart_solutions = [[1,1], [-1,1], [1,-1], [-1,-1]]\n# construct tracker\ntracker = Tracker(H)\n# track each start solution separetely\nresults = track.(tracker, start_solutions)\nprintln(\"# successfull: \", count(is_success, results))\n\nWe see that we tracked all 4 paths successfully.\n\n# successfull: 4\n\n\n\n\n\n","category":"type"},{"location":"tracker/#HomotopyContinuation2.TrackerOptions","page":"Trackers","title":"HomotopyContinuation2.TrackerOptions","text":"TrackerOptions(; options...)\n\nThe set of options for a Tracker.\n\nOptions\n\nmax_steps::Int = 1_000: The maximal number of steps a tracker attempts\nmax_step_size::Float64 = Inf: The maximal size of a step\nmax_initial_step_size::Float64 = Inf: The maximal size of the first step\nmin_step_size::Float64 = 1e-48: The minimal step size. If a smaller step size would be necessary, then the tracking gets terminated.\nextended_precision::Bool = true: Whether to allow for the use of extended precision, if necessary, in some computations. This can greatly improve the ability to track numerically difficult paths.\nterminate_cond::Float64 = 1e13: If the relative component-wise condition number cond(H_x, ẋ) is larger than terminate_cond then the path is terminated as too ill-conditioned.\nparameters::Union{Symbol,TrackerParameters} = :default Set the TrackerParameters to control the performance of the path tracking algorithm. The values :default, :conservative and :fast are shorthands for using DEFAULT_TRACKER_PARAMETERS, CONSERVATIVE_TRACKER_PARAMETERS resp. FAST_TRACKER_PARAMETERS.\n\n\n\n\n\n","category":"type"},{"location":"tracker/#HomotopyContinuation2.TrackerParameters","page":"Trackers","title":"HomotopyContinuation2.TrackerParameters","text":"TrackerParameters\n\nParameters that control the performance and robustness characteristics of the path tracking algorithm. See [Tim20] for an explanation and derivation of the parameters. We provide three sets of parameters for common use cases:\n\nDEFAULT_TRACKER_PARAMETERS\nFAST_TRACKER_PARAMETERS\nCONSERVATIVE_TRACKER_PARAMETERS\n\n[Tim20]: Timme, S. \"Mixed Precision Path Tracking for Polynomial Homotopy Continuation\". arXiv:1902.02968 (2020)\n\n\n\n\n\n","category":"type"},{"location":"tracker/#HomotopyContinuation2.DEFAULT_TRACKER_PARAMETERS","page":"Trackers","title":"HomotopyContinuation2.DEFAULT_TRACKER_PARAMETERS","text":"The default TrackerParameters which have a good balance between robustness and efficiency.\n\n\n\n\n\n","category":"constant"},{"location":"tracker/#HomotopyContinuation2.CONSERVATIVE_TRACKER_PARAMETERS","page":"Trackers","title":"HomotopyContinuation2.CONSERVATIVE_TRACKER_PARAMETERS","text":"TrackerParameters which trade robustness against some speed.\n\n\n\n\n\n","category":"constant"},{"location":"tracker/#HomotopyContinuation2.FAST_TRACKER_PARAMETERS","page":"Trackers","title":"HomotopyContinuation2.FAST_TRACKER_PARAMETERS","text":"TrackerParameters which trade speed against a higher chance of path jumping.\n\n\n\n\n\n","category":"constant"},{"location":"tracker/#Tracking-1","page":"Trackers","title":"Tracking","text":"","category":"section"},{"location":"tracker/#","page":"Trackers","title":"Trackers","text":"track(tracker::Tracker, x₁::AbstractVector, t₁::Number, t₀::Number)","category":"page"},{"location":"tracker/#HomotopyContinuation2.track-Tuple{Tracker,AbstractArray{T,1} where T,Number,Number}","page":"Trackers","title":"HomotopyContinuation2.track","text":" track(tracker::Tracker, x::AbstractVector, t₁ = 1.0, t₀ = 0.0; debug::Bool = false)\n\nTrack the given solution x at t₁ using tracker to a solution at t₀.\n\ntrack(tracker::Tracker, r::TrackerResult, t₁ = 1.0, t₀ = 0.0; debug::Bool = false)\n\nTrack the solution of the result r from t₁ to t₀.\n\n\n\n\n\n","category":"method"},{"location":"tracker/#Result-1","page":"Trackers","title":"Result","text":"","category":"section"},{"location":"tracker/#","page":"Trackers","title":"Trackers","text":"TrackerResult\nsolution(::TrackerResult)\nis_success(::TrackerResult)\nis_invalid_startvalue(::TrackerResult)\nsteps(::TrackerResult)\naccepted_steps(::TrackerResult)\nrejected_steps(::TrackerResult)","category":"page"},{"location":"tracker/#HomotopyContinuation2.TrackerResult","page":"Trackers","title":"HomotopyContinuation2.TrackerResult","text":"TrackerResult{V<:AbstractVector{ComplexF64}}\n\nContaining the result of tracking a path with a Tracker.\n\nFields\n\nreturn_code::Symbol: A code indicating whether the tracking was successfull (:success). See TrackerCode for all possible values.\nsolution::V: The solution when the tracking stopped.\nt::ComplexF64: The value of t when the tracking stopped.\naccuracy::Float64: Estimate of the relative accuracy of the solution.\naccepted_steps::Int: Number of steps that got accepted.\nrejected_steps::Int: Number of steps that got rejected.\nextended_precision::Bool: Indicate whether extended precision is necessary to achieve the accuracy of the solution.\nextended_precision_used::Bool: This is true if during the tracking at any point extended precision was used.\n\n\n\n\n\n","category":"type"},{"location":"tracker/#HomotopyContinuation2.solution-Tuple{TrackerResult}","page":"Trackers","title":"HomotopyContinuation2.solution","text":"solution(result::TrackerResult)\n\nReturns the solutions obtained by the Tracker.\n\n\n\n\n\n","category":"method"},{"location":"tracker/#HomotopyContinuation2.is_success-Tuple{TrackerResult}","page":"Trackers","title":"HomotopyContinuation2.is_success","text":"is_success(result::TrackerResult)\n\nReturns true if the path tracking was successfull.\n\n\n\n\n\n","category":"method"},{"location":"tracker/#HomotopyContinuation2.is_invalid_startvalue-Tuple{TrackerResult}","page":"Trackers","title":"HomotopyContinuation2.is_invalid_startvalue","text":"is_invalid_startvalue(result::TrackerResult)\n\nReturns true if the path tracking failed since the start value was invalid.\n\n\n\n\n\n","category":"method"},{"location":"tracker/#HomotopyContinuation2.steps-Tuple{TrackerResult}","page":"Trackers","title":"HomotopyContinuation2.steps","text":"steps(result::TrackerResult)\n\nReturns the number of steps done.\n\n\n\n\n\n","category":"method"},{"location":"tracker/#HomotopyContinuation2.accepted_steps-Tuple{TrackerResult}","page":"Trackers","title":"HomotopyContinuation2.accepted_steps","text":"accepted_steps(result::TrackerResult)\n\nReturns the number of accepted steps.\n\n\n\n\n\n","category":"method"},{"location":"tracker/#HomotopyContinuation2.rejected_steps-Tuple{TrackerResult}","page":"Trackers","title":"HomotopyContinuation2.rejected_steps","text":"rejected_steps(result::TrackerResult)\n\nReturns the number of rejected_steps steps.\n\n\n\n\n\n","category":"method"},{"location":"tracker/#Low-level-API-1","page":"Trackers","title":"Low-level API","text":"","category":"section"},{"location":"tracker/#","page":"Trackers","title":"Trackers","text":"track!(tracker::Tracker, x₁::AbstractVector, t₁::Number, t₀::Number)\ninit!(tracker::Tracker, ::TrackerResult, ::Number, ::Number)\nTrackerCode\nis_success(::TrackerCode.codes)\nis_tracking(::TrackerCode.codes)\nis_invalid_startvalue(::TrackerCode.codes)\nis_terminated(::TrackerCode.codes)\n","category":"page"},{"location":"tracker/#HomotopyContinuation2.track!-Tuple{Tracker,AbstractArray{T,1} where T,Number,Number}","page":"Trackers","title":"HomotopyContinuation2.track!","text":"track!(tracker::Tracker, x, t₁ = 1.0, t₀ = 0.0; debug::Bool = false)\n\nThe same as track but only returns the final TrackerCode.\n\ntrack!(tracker::Tracker, t₀; debug::Bool = false)\n\nTrack with tracker the current solution to t₀. This keeps the current state.\n\n\n\n\n\n","category":"method"},{"location":"tracker/#HomotopyContinuation2.init!-Tuple{Tracker,TrackerResult,Number,Number}","page":"Trackers","title":"HomotopyContinuation2.init!","text":"init!(tracker::Tracker, x₁, t₁, t₀)\n\nSetup tracker to track x₁ from t₁ to t₀.\n\ninit!(tracker::Tracker, t₀)\n\nSetup tracker to continue tracking the current solution to t₀. This keeps the current state.\n\n\n\n\n\n","category":"method"},{"location":"tracker/#HomotopyContinuation2.TrackerCode","page":"Trackers","title":"HomotopyContinuation2.TrackerCode","text":"TrackerCode\n\nThe possible states a CoreTracker can have are of type TrackerCode.codes and can be\n\nTrackerCode.success: Indicates a successfull tracking.\nTrackerCode.tracking: The tracking is still in progress.\nTrackerCode.terminated_accuracy_limit: Tracking terminaed since the accuracy was insufficient.\nTrackerCode.terminated_invalid_startvalue: Tracking terminated since the provided start value was invalid.\nTrackerCode.terminated_ill_conditioned: Tracking terminated since the path was too ill-conditioned.\nTrackerCode.terminated_max_steps: Tracking terminated since maximal number of steps is reached.\nTrackerCode.terminated_step_size_too_small: Trackint terminated since the step size was too small.\nTrackerCode.terminated_unknown: An unintended error occured. Please consider reporting an issue.\n\n\n\n\n\n","category":"module"},{"location":"tracker/#HomotopyContinuation2.is_success-Tuple{HomotopyContinuation2.TrackerCode.codes}","page":"Trackers","title":"HomotopyContinuation2.is_success","text":"is_success(code::TrackerCode.codes)\n\nReturns true if code indicates a success in the path tracking.\n\n\n\n\n\n","category":"method"},{"location":"tracker/#HomotopyContinuation2.is_tracking-Tuple{HomotopyContinuation2.TrackerCode.codes}","page":"Trackers","title":"HomotopyContinuation2.is_tracking","text":"is_tracking(code::TrackerCode.codes)\n\nReturns true if code indicates that the path tracking is not yet finished.\n\n\n\n\n\n","category":"method"},{"location":"tracker/#HomotopyContinuation2.is_invalid_startvalue-Tuple{HomotopyContinuation2.TrackerCode.codes}","page":"Trackers","title":"HomotopyContinuation2.is_invalid_startvalue","text":"is_invalid_startvalue(code::TrackerCode.codes)\n\nReturns true if code indicates that the path tracking got terminated since the start value was not a zero.\n\n\n\n\n\n","category":"method"},{"location":"tracker/#HomotopyContinuation2.is_terminated-Tuple{HomotopyContinuation2.TrackerCode.codes}","page":"Trackers","title":"HomotopyContinuation2.is_terminated","text":"is_terminated(code::TrackerCode.codes)\n\nReturns true if code indicates that the path tracking got terminated.\n\n\n\n\n\n","category":"method"},{"location":"#Introduction-1","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"HomotopyContinuation.jl is a package for the numerical solution of systems of polynomial equations.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"This documentation is a purely technical description of the package functionality. You can find tutorials, examples, how-to guides and explanations on our homepage JuliaHomotopyContinuation.org.","category":"page"},{"location":"#Contents-1","page":"Introduction","title":"Contents","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"Problem formulation","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Pages = [\n    \"model_kit.md\",\n    \"linear_affine.md\",\n    \"systems_homotopies.md\",\n]\nDepth = 2","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Trackers","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Pages = [\n    \"path_tracker.md\",\n    \"tracker.md\",\n]\nDepth = 2","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Miscellaneous","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Pages = [\n    \"misc.md\",\n]\nDepth = 2","category":"page"}]
}
